<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport">
  <meta name="robots" content="index, follow">
  <!-- title -->
  
    
  <title>为什么一定要有一个个人网站？ - 子规入梧桐</title>
    
  
  
  <!-- open graph -->
  <meta name="description" content="前言大家好，我是子规，很高兴能够在这里和大家相遇。本篇文章记录该站建立的初衷、建站过程以及在过程中的思考。 为什么建立这个网站在此网站建立之前，我通常在CSDN上写作。 但随着时间推移，我开始发现，CSDN上的文章， Although it is very good, but it is not very good for SEO。尽管我在CSDN上没有很多有质量的输出，但是繁杂的信息流却充斥在我">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么一定要有一个个人网站？">
<meta property="og:url" content="https://www.lazydaily.cn/761386768996832/index.html">
<meta property="og:site_name" content="子规入梧桐">
<meta property="og:description" content="前言大家好，我是子规，很高兴能够在这里和大家相遇。本篇文章记录该站建立的初衷、建站过程以及在过程中的思考。 为什么建立这个网站在此网站建立之前，我通常在CSDN上写作。 但随着时间推移，我开始发现，CSDN上的文章， Although it is very good, but it is not very good for SEO。尽管我在CSDN上没有很多有质量的输出，但是繁杂的信息流却充斥在我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-23T01:43:49.781Z">
<meta property="article:author" content="z1gui">
<meta property="article:tag" content="随笔">
<meta name="twitter:card" content="summary">
  <!-- canonical -->
  
  <link rel="canonical" href="https://www.lazydaily.cn/761386768996832/">
  
  <!-- Favicon -->
  <link rel="shortcut icon" href="/img/favicon.png">
  
  <!-- Google Fonts 预加载 - 优化字体加载 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  
  <!-- 预加载所有字体 -->
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;1,400&amp;family=Noto+Serif:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&amp;family=Noto+Serif+SC:wght@400;700;900&amp;display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;1,400&amp;family=Noto+Serif:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&amp;family=Noto+Serif+SC:wght@400;700;900&amp;display=swap">
  
  <!-- 字体加载优化脚本 -->
  <script>
    // 字体加载优化
    (function() {
      // 检查是否支持Font Loading API
      if ('fonts' in document) {
        // 异步加载字体，不阻塞页面渲染
        setTimeout(function() {
          Promise.all([
            document.fonts.load('400 1em "JetBrains Mono"'),
            document.fonts.load('400 1em "Noto Serif"'),
            document.fonts.load('400 1em "Noto Serif SC"')
          ]).then(function() {
            document.documentElement.classList.add('fonts-loaded');
          }).catch(function() {
            document.documentElement.classList.add('fonts-fallback');
          });
        }, 0);
      } else {
        // 不支持Font Loading API的浏览器，直接使用系统字体
        document.documentElement.classList.add('fonts-fallback');
      }
    })();
  </script>
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/reset.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/markdown.css">

  
<link rel="stylesheet" href="/css/fonts.css">

  
<link rel="stylesheet" href="/css/a11y-dark.min.css">

  
  <!-- 图片懒加载 -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // 预加载队列
      const preloadQueue = [];
      let isProcessing = false;
      let processedImages = new Set();
      
      // 创建loading效果
      function createLoadingEffect(img) {
        // 检查是否已经有容器
        let container = img.parentElement;
        if (!container || !container.classList.contains('image-container')) {
          // 创建图片容器
          container = document.createElement('div');
          container.className = 'image-container loading';
          
          // 将图片包装在容器中
          img.parentNode.insertBefore(container, img);
          container.appendChild(img);
        } else {
          // 如果已有容器，添加loading类
          container.classList.add('loading');
        }
        
        return container;
      }
      
      // 移除loading效果
      function removeLoadingEffect(container) {
        if (container && container.classList.contains('loading')) {
          container.classList.remove('loading');
        }
      }
      
      // 处理预加载队列
      function processPreloadQueue() {
        if (isProcessing || preloadQueue.length === 0) return;
        
        isProcessing = true;
        const img = preloadQueue.shift();
        
        if (img && img.dataset.src && !processedImages.has(img)) {
          processedImages.add(img);
          
          // 添加loading效果
          const container = createLoadingEffect(img);
          
          img.src = img.dataset.src;
          
          img.addEventListener('load', function() {
            img.classList.add('loaded');
            removeLoadingEffect(container);
            isProcessing = false;
            // 继续处理队列中的下一张图片
            setTimeout(processPreloadQueue, 10);
          });
          
          img.addEventListener('error', function() {
            removeLoadingEffect(container);
            isProcessing = false;
            // 继续处理队列中的下一张图片
            setTimeout(processPreloadQueue, 10);
          });
        } else {
          isProcessing = false;
          // 继续处理队列中的下一张图片
          setTimeout(processPreloadQueue, 10);
        }
      }
      
      // 处理所有图片
      function handleImages() {
        // 选择所有懒加载图片，但排除favicon
        const lazyImages = document.querySelectorAll('.lazy-image');
        const allImages = document.querySelectorAll('img');
        

        
        // 如果没有懒加载图片，检查是否有需要处理的图片
        if (lazyImages.length === 0) {
          allImages.forEach(img => {
            // 排除favicon.png
            if (img.src && !img.src.includes('favicon.png') && !img.src.includes('github.png') && !img.src.includes('mail.png') && !img.src.includes('rss-fill.png') && !img.src.includes('Telegram.png') &&
                img.dataset.src && !img.classList.contains('lazy-image')) {
              // 如果有data-src属性，说明是懒加载图片
              img.classList.add('lazy-image');
              
              // 添加loading效果
              const container = createLoadingEffect(img);
              
              // 立即加载图片
              img.src = img.dataset.src;
              
              // 图片加载完成后的处理
              img.addEventListener('load', function() {
                img.classList.add('loaded');
                removeLoadingEffect(container);
              });
              
              img.addEventListener('error', function() {
                removeLoadingEffect(container);
              });
            }
          });
          return;
        }
        
        // 使用Intersection Observer处理懒加载图片
        const imageObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              
              // 检查是否有data-src属性
              if (img.dataset.src && !processedImages.has(img)) {
                // 将图片添加到预加载队列
                preloadQueue.push(img);
                processPreloadQueue();
              } else if (!img.dataset.src) {
                // 如果没有data-src，直接显示图片
                img.classList.add('loaded');
              }
              
              // 停止观察这个图片
              observer.unobserve(img);
            }
          });
        }, {
          rootMargin: '400px 0px', // 提前400px开始加载，大幅提升加载速度
          threshold: 0.001 // 降低阈值，图片刚进入视口就开始加载
        });
        
        // 开始观察所有懒加载图片
        lazyImages.forEach(img => {
          // 排除favicon.png
          if (!img.src.includes('favicon.png') && !img.src.includes('github.png') && !img.src.includes('mail.png') && !img.src.includes('rss-fill.png') && !img.src.includes('Telegram.png')) {
            imageObserver.observe(img);
          }
        });
      }
      
      // 立即执行一次
      handleImages();
      
      // 减少延迟时间，提升响应速度
      setTimeout(handleImages, 20);
    });
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="子规入梧桐" type="application/atom+xml">
</head>

    <body class="is-post">
        <!-- 侧边提示条 -->
        
        <div class="header-hint" id="headerHint"></div>
        
        
        <div class="paper">
            <div class="paper-main">
                <div class="header">
    <div class="header-nav-buttons">
        
            
            <a href="/" class="header-nav-btn " title="主页">
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 9L12 2L21 9V20C21 20.5304 20.7893 21.0391 20.4142 21.4142C20.0391 21.7893 19.5304 22 19 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V9Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9 22V12H15V22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </a>
        
            
            <a href="/archives" class="header-nav-btn " title="归档">
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 16V8C20.9996 7.64927 20.9071 7.30481 20.7315 7.00116C20.556 6.69751 20.3037 6.44536 20 6.27L13 2.27C12.696 2.09446 12.3511 2.00205 12 2.00205C11.6489 2.00205 11.304 2.09446 11 2.27L4 6.27C3.69626 6.44536 3.44398 6.69751 3.26846 7.00116C3.09294 7.30481 3.00036 7.64927 3 8V16C3.00036 16.3507 3.09294 16.6952 3.26846 16.9988C3.44398 17.3025 3.69626 17.5546 4 17.73L11 21.73C11.304 21.9055 11.6489 21.9979 12 21.9979C12.3511 21.9979 12.696 21.9055 13 21.73L20 17.73C20.3037 17.5546 20.556 17.3025 20.7315 16.9988C20.9071 16.6952 20.9996 16.3507 21 16Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </a>
        
            
            <a href="/about" class="header-nav-btn " title="关于">
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 21V19C20 17.9391 19.5786 16.9217 18.8284 16.1716C18.0783 15.4214 17.0609 15 16 15H8C6.93913 15 5.92172 15.4214 5.17157 16.1716C4.42143 16.9217 4 17.9391 4 19V21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </a>
        
            
            <a href="/use" class="header-nav-btn " title="设备">
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="3" width="20" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></rect><path d="M8 21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12 17V21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </a>
        
            
            <a href="https://uhufoundme.sol.build/" class="header-nav-btn " title="碎碎念" target="&quot;_blank&quot;" rel="&quot;noopener" noreferrer&#34;="">
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9 7H7V9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M7 17V15H9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M17 7H15V9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M15 17H17V15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </a>
        
    </div>
</div>

                <div class="post-main">
    <!-- 阅读进度条 -->
    <div class="reading-progress-bar" id="readingProgressBar"></div>
    
    
        <div class="post-main-title">
            为什么一定要有一个个人网站？
        </div>
        <div class="post-meta">
            <div class="post-meta-left">
                2025年04月24日 ｜ 
                
                    <a href="/tags/%E9%9A%8F%E7%AC%94/" class="tag-link"># 随笔</a>
                
            </div>
            <div class="post-meta-right">
                <span class="post-stats-minimal" id="postStats">
                    <span class="stat-value-minimal" id="wordCount" title="字数统计">-</span>
                    <span class="stat-separator-minimal">·</span>
                    <span class="stat-value-minimal" id="readingTime" title="预计阅读时长">-</span>
                </span>
            </div>
        </div>

        <div class="post-content-wrapper">
            <div class="post-content-main">
                <div class="post-md">
                    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是子规，很高兴能够在这里和大家相遇。本篇文章记录该站建立的初衷、建站过程以及在过程中的思考。</p>
<h2 id="为什么建立这个网站"><a href="#为什么建立这个网站" class="headerlink" title="为什么建立这个网站"></a>为什么建立这个网站</h2><p>在此网站建立之前，我通常在CSDN上写作。</p>
<p>但随着时间推移，我开始发现，CSDN上的文章， Although it is very good, but it is not very good for SEO。尽管我在CSDN上没有很多有质量的输出，但是繁杂的信息流却充斥在我面前。关注，点赞，私信，评论，活动等等都是我要面对的。这些信息流无时无刻不在分散我的注意力，使我感到非常痛苦。</p>
<p>因此，我开始探索更有效的方式。前几年微信公众号爆火，我本人也关注不少微信公众号。其中，有非常多关于编程的公众号对我帮助极大，我非常喜欢。时常幻想自己能够在公众号上写好文章，这样我就可以分享自己的知识了，或者说更纯粹的分享自己的知识了。</p>
<p>我也的确这么做了，「整点儿代码」就是尝试。「整点儿代码」最初的规划是，每天产出一篇文章，设置定时晚上10点左右发布，这也 call back 了“整点”这个 concept。可惜，我并没有成功。一方面微信公众号的审核不通过导致不能整点发布，让我十分困扰。另一方面，就是个人没有坚持下来。最重要的一点是，我仍然没有从关注，点赞，私信，评论中脱离出来。是的，公众号也有这样的问题需要我面对。显然，这不是我想要的、理想的博客记录方式。</p>
<p>最终，我决定做一个自己的博客网站。</p>
<h2 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h2><p>2022 年，我了解到，GitHub Pages 是一个非常优秀的博客托管平台。基于 Git 方式的 post 和自动化发布节省了我不少的时间，也使我更专注于内容的编写。确定了服务托管方式，剩下的工作就是考虑网站搭建技术方向了。互联网上关于博客类网站建设的技术已经非常成熟了，Wordpress，Vuepress，Docsify，Hexo，Next.js 等等。</p>
<h3 id="Docsify"><a href="#Docsify" class="headerlink" title="Docsify"></a>Docsify</h3><p>最开始时候，我比较欣赏 Docsify 这种静态简单的风格。Docsify 本身支持的插件丰富，包括评论系统，访问次数，字数统计，页面搜索等，可以大大节省自己开发的时间。此外，将项目部署到 Github 上，使用 Github Page 托管之后，不用维护本地文档。编写文章发布也不需要编译，只要提交文件，等待自动部署即可。</p>
<p>你可以访问 <a target="_blank" rel="noopener" href="https://z1gui.github.io/chips/#/"> https://z1gui.github.io/chips/#/ </a> 来查看页面。该项目搭建具体参考了<a target="_blank" rel="noopener" href="https://bugstack.cn/">小傅哥</a>的这篇博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/generalfu/article/details/123268118?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522815fa9b0be7b0090fc06b78edb862108%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=815fa9b0be7b0090fc06b78edb862108&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-123268118-null-null.nonecase&amp;utm_term=docsify&amp;spm=1018.2226.3001.4450">《# 在GitHub/Gitee上，搭建一个简单的所见即所得博客》</a>。如果你觉得这个样式符合自己的审美，也可以参考我仓库里面的这个项目 <a target="_blank" rel="noopener" href="https://github.com/z1gui/chips"> https://github.com/z1gui/chips </a> 配置。</p>
<p>期间，我还尝试将 Docsify 部署到云服务器上，后来发现不如在 Github 上好管理，遂放弃。</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>再后来，我发现 docsify 很好，但是不够好。在文章展示，以及必要插件上，docsify 能满足一个博客的基础功能。但是，docsify 没有标签，分类，归档等功能。虽然我不追求极致的动效和交互效果，但 Docsify 过于简单的交互效果，让我感觉在阅读一个在线的 markdown 阅读器。与此同时，在 V2ex 的 VXNA 模块看过太多优秀博主的博客，让我又一次萌生了改博客样式的念头。</p>
<p>我开始尝试使用 Hexo 博客框架。Hexo 是一个快速、简单、功能强大的博客框架。你使用&nbsp;<a target="_blank" rel="noopener" href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）撰写帖子，Hexo 会在几秒钟内生成具有漂亮主题的静态文件。</p>
<p>本站当前使用 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 搭建，使用 <a target="_blank" rel="noopener" href="https://github.com/z1gui/hexo-theme-ZenMind-Pro">hexo-theme-ZenMind-Pro</a> 主题搭建。<strong>hexo-theme-ZenMind-Pro</strong> 是本人在 <a target="_blank" rel="noopener" href="https://github.com/zhoulianglen/hexo-theme-ZenMind">hexo-theme-ZenMind</a> 主题上做了修改优化。如有问题，可以联系我或在 issues 中提出您的问题。<strong>在此感谢 <a target="_blank" rel="noopener" href="https://github.com/zhoulianglen">@周良粥凉</a> 的主题以及其博客样式参考</strong>。</p>
<p>在改造 hexo-theme-ZenMind 过程中，我大量使用了 Cursor 进行编程开发。一般来说，简单的样式调整，以及想要达成的效果 Cursor 都能够轻松完成。如果你对 Cursor 编程感兴趣，请参考这篇文章 [[「持续更新」AI辅助编程使用心得]]。其实，Hexo 丰富的生态，即使不二次开发，我相信你也能找到自己心仪的样式框架。</p>
<h2 id="如何写好自己的博客"><a href="#如何写好自己的博客" class="headerlink" title="如何写好自己的博客"></a>如何写好自己的博客</h2><p>从一开始下定决心写博客，我也是迷茫的。什么写，什么不写，这些很难形成一个标准。</p>
<p>究其原因，大部分在写博客的时候，我都在想如何让读者读明白，又如何让读者快速理解。参考我早期的博客就能看出来，有些概念太想解释清楚，以至于长篇大论，尽管它可能很简单。 后来，我意识到博客其实是给自己的知识做沉淀，目的是让自己 “知其所以然”。以这个思想来写博客，会发现写好博客并不难。</p>
<p>这是关于《如何写好自己的博客》我想说的其一，<strong>「以自己为中心，让自己 “知其所以然”」。</strong> 大多数人写博客是为了提升自己的知识水平，提升自己的专业技能，形成一个自己的知识体系。<strong>「如何通过博客建立自己的知识体系」</strong> ，便是我想要说的其二。</p>
<p>后来有幸拜读 pdai 佬引用的<a target="_blank" rel="noopener" href="https://pdai.tech/md/team/team-z-tixi.html">《知识体系：如何构建自己的知识体系》</a>，醍醐灌顶，感受颇多。这里引用一下文章中的话：</p>
<blockquote>
<p>我们的学习分为四阶段：输入、内化、沉淀、输出。碎片化在输入的时候用，因为信息本身是碎片化的，时间也是碎片化的，所以输入信息的时候，要碎片化。但有需要体系化的沉淀。因此碎片化的输入，加上体系化的沉淀，你就可以实现利用碎片化的时间，做体系化的学习。</p>
</blockquote>
<p>整篇文章中，强调了“碎片化学习”形成“体系化技能”。并总结出相应的三个步骤：定目标、搭建知识体系、填内容。其实建立自己的博客，写好自己的博客，也遵从着三个步骤。</p>
<p>这里就扣合了之前提的第一点。在我看来，建立博客的目标应是让自己“知其所以然”。在这个目标下，再去定义体系，填写内容。当然，再后来我发现博客也可以是一个思想沉淀的地方，久而久之我也会将自己的一些体验，感悟放在这里，这是后话，容我们日后再谈。</p>
<p>对我来说，建立博客更像是形成自己知识体系，总结人生感悟的具象化的体现。</p>

                </div>
            </div>
            <div class="post-content-sidebar">
                
                <div class="post-toc" id="postToc">
                    <div class="toc-header">
                        <div class="toc-title">目录</div>
                    </div>
                    <div class="toc-content"></div>
                </div>
            </div>
        </div>
    

<!-- 只在文章页面显示分类和导航 -->

    <!-- 分类信息和分享按钮 -->
    
        <div class="post-categories-with-share">
            <div class="post-categories">
                分类：
                
                    <a href="/categories/%E7%94%9F%E6%B4%BB/"> / 生活</a>
                
            </div>
            <div class="post-action-buttons">
                <button class="comment-toggle-btn" id="commentToggleBtn" title="显示/隐藏评论">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                    </svg>
                </button>
                <button class="share-icon-btn" id="shareBtn" title="点击分享这篇文章">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                    </svg>
                </button>
                
            </div>
        </div>
    

   

    <!-- 评论抽屉容器（抽屉动画区域） -->
    <div id="commentsDrawer" class="comments-drawer" aria-hidden="true">
        <!-- 评论区域 -->
        <div class="comments-section" id="commentsSection">
            
<div class="giscus-container">
    <script src="https://giscus.app/client.js" data-repo="z1gui/blog" data-repo-id="R_kgDOOezL6g" data-category="Announcements" data-category-id="DIC_kwDOOezL6s4CvusN" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="noborder_gray" data-lang="zh-CN" crossorigin="anonymous" async="">
    </script>
</div>


        </div>
    </div>

    <!-- 下一篇推荐 -->
    
    <div class="next-post-recommendation">
        <div class="next-post-label">接下来阅读</div>
        <div class="next-post-content">
            <a href="/176138676899684/" class="next-post-title">JavaScript 创建执行释放过程</a>
            <a href="/176138676899684/" class="next-post-excerpt">
                
                一、对象创建过程a. 内存分配 当我们创建一个对象时（无论是通过构造函数还是字面量方式），JavaScript 引擎会在内存堆（Heap）中为这个对象分配空间。堆是一个用于存储复杂数据结构（如对象和数组）的区域。 // 创建对象并分配内存 var person = new Object; person.name = &amp;39;Alice&amp;39;; person.age = 30; 或 // 字面量方式创建对象并分配内存 var person = &amp;123;   name: &amp;39;Alice&amp;39;,   age: 30 &amp;125;; b. 构造函数调用 如果使用 new 关键字调用构造函数来创...
            </a>
        </div>
    </div>
    


</div>

<!-- 图片全屏显示模态框 -->
<div class="image-modal" id="imageModal">
    <img id="modalImage" src="" alt="全屏图片">
</div>

<!-- 分享成功弹出通知 -->
<div class="share-notification" id="shareNotification">
    <div class="share-notification-content">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 12L11 14L15 10M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
        <span>链接已复制到剪贴板</span>
    </div>
</div>

<!-- 代码全屏显示模态框 -->
<div class="code-modal" id="codeModal">
    <div class="code-modal-content">
        <div class="code-modal-header">
            <div class="code-modal-title">代码查看</div>
            <div class="code-modal-close" id="codeModalClose">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
        </div>
        <div class="code-modal-code">
            <pre><code id="modalCode"></code></pre>
        </div>
    </div>
</div>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const postImages = document.querySelectorAll('.post-md img');

    // 为图片添加说明文字（优先 data-caption，其次 alt，最后 title）
    // 只在文章页面显示图片标注，设备页面不显示
    if (document.body.classList.contains('is-post')) {
    postImages.forEach(img => {
        // 跳过社交链接中的图标
        const isSocialIcon = img.closest('.social-links') !== null;
        if (isSocialIcon) return;

        // 已有说明则不重复添加（检测紧邻的说明节点）
        const container = img.closest('.image-container');
        const link = img.closest('a');
        const injector = link || container || img;
        const nextEl = injector.nextElementSibling;
        if (nextEl && nextEl.classList && nextEl.classList.contains('image-caption')) return;

        const captionText = (img.getAttribute('data-caption') || img.getAttribute('alt') || img.getAttribute('title') || '').trim();
        if (!captionText) return;

        const captionEl = document.createElement('div');
        captionEl.className = 'image-caption';
        captionEl.textContent = captionText;

        injector.insertAdjacentElement('afterend', captionEl);
    });
    }

    // 点击图片打开模态框
    postImages.forEach(img => {
        // 检查图片是否在社交链接中
        const isSocialIcon = img.closest('.social-links') !== null;
        if (!isSocialIcon) {
            img.addEventListener('click', function() {
                modal.classList.add('active');
                
                // 获取原始图片路径（将WebP转换回原始格式）
                let originalSrc = this.src || this.dataset.src;
                
                // 如果是WebP格式，转换为原始格式
                if (originalSrc && originalSrc.includes('.webp')) {
                    // 尝试多种原始格式
                    const possibleFormats = ['.png', '.jpg', '.jpeg'];
                    let foundOriginal = false;
                    
                    for (let format of possibleFormats) {
                        const testSrc = originalSrc.replace('.webp', format);
                        // 这里可以添加预检查逻辑，但为了简化，我们直接尝试加载
                        if (!foundOriginal) {
                            originalSrc = testSrc;
                            foundOriginal = true;
                        }
                    }
                    
                    // 如果都没有找到，使用默认的.jpg格式
                    if (!foundOriginal) {
                        originalSrc = originalSrc.replace('.webp', '.jpg');
                    }
                }
                
                modalImg.src = originalSrc;
                document.body.style.overflow = 'hidden'; // 防止背景滚动
                
                // 添加加载状态
                modalImg.onload = function() {
                    console.log('原始图片加载完成:', originalSrc);
                };
                
                modalImg.onerror = function() {
                    console.log('原始图片加载失败，尝试其他格式');
                    // 尝试其他可能的原始格式
                    const webpSrc = this.src || this.dataset.src;
                    if (webpSrc && webpSrc.includes('.webp')) {
                        const formats = ['.png', '.jpeg', '.jpg'];
                        let currentFormatIndex = 0;
                        
                        const tryNextFormat = () => {
                            if (currentFormatIndex < formats.length) {
                                const testSrc = webpSrc.replace('.webp', formats[currentFormatIndex]);
                                modalImg.src = testSrc;
                                currentFormatIndex++;
                            } else {
                                console.log('所有原始格式都失败，使用WebP版本');
                                modalImg.src = webpSrc;
                            }
                        };
                        
                        // 重新绑定错误处理
                        modalImg.onerror = tryNextFormat;
                        tryNextFormat();
                    } else {
                        modalImg.src = webpSrc;
                    }
                }.bind(this);
            });
        }
    });

    // 点击模态框关闭
    modal.addEventListener('click', function() {
        modal.classList.remove('active');
        document.body.style.overflow = ''; // 恢复背景滚动
    });

    // 按 ESC 键关闭模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    });

    // 阅读进度条功能
    const progressBar = document.getElementById('readingProgressBar');
    if (progressBar) {
        function updateReadingProgress() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            
            // 限制进度条宽度在0-100%之间
            const progressWidth = Math.min(Math.max(scrollPercent, 0), 100);
            progressBar.style.width = progressWidth + '%';
        }

        // 监听滚动事件
        window.addEventListener('scroll', updateReadingProgress);
        
        // 页面加载时初始化进度条
        updateReadingProgress();
    }

    



    // 返回顶部功能
    const backToTopBtn = document.getElementById('backToTopBtn');
    if (backToTopBtn) {
        backToTopBtn.addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    }

    // 代码块全屏功能
    const codeModal = document.getElementById('codeModal');
    const modalCode = document.getElementById('modalCode');
    const codeModalClose = document.getElementById('codeModalClose');

    // 为所有代码块添加全屏按钮
    const codeBlocks = document.querySelectorAll('.post-md pre');
    codeBlocks.forEach(pre => {
        // 检查是否已经有按钮（避免重复添加）
        if (!pre.querySelector('.code-fullscreen-btn')) {
            const fullscreenBtn = document.createElement('div');
            fullscreenBtn.className = 'code-fullscreen-btn';
            fullscreenBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 3H5C3.89543 3 3 3.89543 3 5V8M21 8V5C21 3.89543 20.1046 3 19 3H16M16 21H19C20.1046 21 21 20.1046 21 19V16M3 16V19C3 20.1046 3.89543 21 5 21H8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            fullscreenBtn.title = '全屏查看代码';
            
            // 点击按钮显示全屏代码
            fullscreenBtn.addEventListener('click', function() {
                const codeElement = pre.querySelector('code');
                if (codeElement) {
                    // 检查是否是已经应用了行号的代码块
                    const hljsTable = pre.querySelector('table.hljs-ln');
                    
                    let codeContent;
                    let startLineNumber = 1;
                    
                    if (hljsTable) {
                        // 如果有行号表格，提取纯代码内容和起始行号
                        const codeLines = hljsTable.querySelectorAll('.hljs-ln-code');
                        codeContent = Array.from(codeLines).map(line => {
                            // 提取每行的文本内容，保持原始格式
                            return line.textContent || line.innerText || ' ';
                        }).join('\n');
                        
                        // 获取起始行号
                        const firstNumberCell = hljsTable.querySelector('.hljs-ln-numbers');
                        if (firstNumberCell) {
                            const lineAttr = firstNumberCell.getAttribute('data-line-number');
                            if (lineAttr) {
                                startLineNumber = parseInt(lineAttr) || 1;
                            }
                        }
                    } else {
                        // 普通代码块，直接获取文本内容
                        codeContent = codeElement.textContent || codeElement.innerText;
                    }
                    
                    const codeLanguage = getCodeLanguage(codeElement);
                    
                    // 设置模态框中的代码内容
                    modalCode.textContent = codeContent;
                    modalCode.className = codeElement.className; // 保持代码高亮的类名
                    
                    // 如果原代码有自定义起始行号，设置data属性
                    if (startLineNumber !== 1) {
                        modalCode.setAttribute('data-ln-start-from', startLineNumber);
                    } else {
                        modalCode.removeAttribute('data-ln-start-from');
                    }
                    
                    // 更新标题
                    const modalTitle = document.querySelector('.code-modal-title');
                    if (codeLanguage) {
                        modalTitle.textContent = `代码查看 - ${codeLanguage}`;
                    } else {
                        modalTitle.textContent = '代码查看';
                    }
                    
                    // 显示模态框
                    codeModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    
                    // 重新应用代码高亮和行号
                    if (typeof hljs !== 'undefined') {
                        hljs.highlightElement(modalCode);
                        
                        // 应用行号
                        if (typeof hljs.lineNumbersBlock !== 'undefined') {
                            hljs.lineNumbersBlock(modalCode, {
                                startFrom: startLineNumber
                            });
                        }
                    }
                }
            });
            
            pre.appendChild(fullscreenBtn);
        }
    });

    // 获取代码语言
    function getCodeLanguage(codeElement) {
        const className = codeElement.className;
        const languageMatch = className.match(/language-(\w+)|hljs-(\w+)|\b(\w+)$/);
        if (languageMatch) {
            return languageMatch[1] || languageMatch[2] || languageMatch[3];
        }
        return '';
    }

    // 关闭代码全屏模态框
    function closeCodeModal() {
        codeModal.classList.remove('active');
        document.body.style.overflow = '';
    }

    // 点击关闭按钮
    if (codeModalClose) {
        codeModalClose.addEventListener('click', closeCodeModal);
    }

    // 点击模态框背景关闭（点击内容区域不关闭）
    codeModal.addEventListener('click', function(e) {
        if (e.target === codeModal) {
            closeCodeModal();
        }
    });

    // 按 ESC 键关闭代码模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (codeModal.classList.contains('active')) {
                closeCodeModal();
            }
        }
    });

    // 分享功能
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
        shareBtn.addEventListener('click', function() {
            // 获取文章信息
            const title = document.querySelector('.post-main-title')?.textContent?.trim() || '未知标题';
            const date = document.querySelector('.post-meta')?.textContent?.match(/\d{4}-\d{2}-\d{2}/)?.[0] || '';
            const url = window.location.href;
            
            // 获取文章前几行内容（排除标题、元信息等）
            const postContent = document.querySelector('.post-md');
            let content = '';
            if (postContent) {
                // 获取所有段落和文本内容
                const paragraphs = postContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6');
                const contentArray = [];
                
                for (let i = 0; i < Math.min(paragraphs.length, 3); i++) {
                    const text = paragraphs[i].textContent?.trim();
                    if (text && text.length > 0) {
                        contentArray.push(text);
                    }
                }
                
                content = contentArray.join('\n\n');
                
                // 如果内容太长，截取前100个字符
                if (content.length > 100) {
                    content = content.substring(0, 100) + '...';
                }
            }
            
            // 构建分享内容
            let shareText = `文章标题： ${title}`;
            if (date) {
                shareText += `\n发布时间： ${date}`;
            }
            if (content) {
                shareText += `\n\n${content}`;
            }
            shareText += `\n\n🔗 ${url}`;
            
            // 复制到剪贴板
            if (navigator.clipboard && window.isSecureContext) {
                // 使用现代 Clipboard API
                navigator.clipboard.writeText(shareText).then(function() {
                    showShareSuccess();
                }).catch(function(err) {
                    console.error('复制失败:', err);
                    fallbackCopyTextToClipboard(shareText);
                });
            } else {
                // 降级方案
                fallbackCopyTextToClipboard(shareText);
            }
        });
    }
    
    // 显示分享成功提示
    function showShareSuccess() {
        const notification = document.getElementById('shareNotification');
        if (notification) {
            notification.classList.add('show');
            
            // 3秒后自动隐藏
            setTimeout(function() {
                notification.classList.remove('show');
            }, 3000);
        }
    }
    
    // 降级复制方案
    function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.top = '0';
        textArea.style.left = '0';
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                showShareSuccess();
            } else {
                alert('复制失败，请手动复制以下内容：\n\n' + text);
            }
        } catch (err) {
            console.error('复制失败:', err);
            alert('复制失败，请手动复制以下内容：\n\n' + text);
        }
        
        document.body.removeChild(textArea);
    }
    
    // 字数统计和阅读时长计算
    function calculatePostStats() {
        const postContent = document.querySelector('.post-md');
        if (!postContent) return;
        
        // 获取纯文本内容
        let textContent = postContent.textContent || postContent.innerText || '';
        
        // 移除多余的空白字符
        textContent = textContent.replace(/\s+/g, ' ').trim();
        
        // 计算中文字符数（包括中文标点）
        const chineseChars = textContent.match(/[\u4e00-\u9fff\u3400-\u4dbf\uf900-\ufaff]/g);
        const chineseCount = chineseChars ? chineseChars.length : 0;
        
        // 计算英文单词数
        const englishWords = textContent.match(/[a-zA-Z]+/g);
        const englishWordCount = englishWords ? englishWords.length : 0;
        
        // 计算数字
        const numbers = textContent.match(/\d+/g);
        const numberCount = numbers ? numbers.length : 0;
        
        // 总字数 = 中文字符数 + 英文单词数 + 数字个数
        const totalWords = chineseCount + englishWordCount + numberCount;
        
        // 更新字数显示
        const wordCountElement = document.getElementById('wordCount');
        if (wordCountElement) {
            wordCountElement.textContent = `${totalWords.toLocaleString()} 字`;
            // 更新title属性显示详细信息
            wordCountElement.title = `字数统计：${totalWords.toLocaleString()} 字\n中文字符：${chineseCount}\n英文单词：${englishWordCount}\n数字：${numberCount}`;
        }
        
        // 计算阅读时长（中文按300字/分钟，英文按200词/分钟计算）
        const chineseReadingTime = Math.ceil(chineseCount / 300);
        const englishReadingTime = Math.ceil(englishWordCount / 200);
        const totalReadingTime = Math.max(chineseReadingTime, englishReadingTime, 1); // 至少1分钟
        
        // 更新阅读时长显示
        const readingTimeElement = document.getElementById('readingTime');
        if (readingTimeElement) {
            let displayText = '';
            if (totalReadingTime < 60) {
                displayText = `${totalReadingTime} 分钟`;
            } else {
                const hours = Math.floor(totalReadingTime / 60);
                const minutes = totalReadingTime % 60;
                if (minutes === 0) {
                    displayText = `${hours} 小时`;
                } else {
                    displayText = `${hours} 小时 ${minutes} 分钟`;
                }
            }
            readingTimeElement.textContent = displayText;
            // 更新title属性显示详细信息
            readingTimeElement.title = `预计阅读时长：${displayText}\n基于中文300字/分钟，英文200词/分钟计算`;
        }
        
        // 添加详细统计信息（可选，用于调试）
        console.log('文章统计:', {
            中文字符: chineseCount,
            英文单词: englishWordCount,
            数字个数: numberCount,
            总字数: totalWords,
            预计阅读时长: totalReadingTime + ' 分钟'
        });
    }
    
    // 页面加载完成后计算统计信息
    calculatePostStats();
    
    // 评论区域显示/隐藏功能（顶部按钮仍可用）
    const commentToggleBtn = document.getElementById('commentToggleBtn');
    const commentsSection = document.getElementById('commentsSection');
    const commentsDrawer = document.getElementById('commentsDrawer');
    const commentsToggleBar = document.getElementById('commentsToggleBar');
    
    function openComments() {
        if (commentsDrawer) {
            commentsDrawer.classList.add('open');
            commentsDrawer.setAttribute('aria-hidden', 'false');
        }
        if (commentsToggleBar) {
            commentsToggleBar.setAttribute('aria-expanded', 'true');
            commentsToggleBar.textContent = '隐藏评论';
        }
        if (commentToggleBtn) {
            commentToggleBtn.setAttribute('title', '隐藏评论');
            commentToggleBtn.style.background = 'var(--font-color-0, #ff4444)';
            commentToggleBtn.style.borderColor = 'var(--font-color-0, #ff4444)';
            commentToggleBtn.style.color = 'white';
        }
    }
    
    function closeComments() {
        if (commentsDrawer) {
            commentsDrawer.classList.remove('open');
            commentsDrawer.setAttribute('aria-hidden', 'true');
        }
        if (commentsToggleBar) {
            commentsToggleBar.setAttribute('aria-expanded', 'false');
            commentsToggleBar.textContent = '显示评论';
        }
        if (commentToggleBtn) {
            commentToggleBtn.setAttribute('title', '显示评论');
            commentToggleBtn.style.background = '';
            commentToggleBtn.style.borderColor = '';
            commentToggleBtn.style.color = '';
        }
    }

    if (commentsDrawer && commentsToggleBar) {
        closeComments(); // 默认关闭抽屉
        commentsToggleBar.addEventListener('click', function() {
            if (commentsDrawer.classList.contains('open')) {
                closeComments();
            } else {
                openComments();
            }
        });
    }

    if (commentToggleBtn && commentsDrawer) {
        commentToggleBtn.addEventListener('click', function() {
            if (commentsDrawer.classList.contains('open')) {
                closeComments();
            } else {
                openComments();
            }
        });
    }
});
</script>

                
            </div>
        </div>

        <!-- JavaScript -->
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const html = document.documentElement;
            const header = document.querySelector('.header');
            const headerHint = document.getElementById('headerHint');
            
            // 大屏文章页的header自动隐藏功能
            if (document.body.classList.contains('is-post') && window.innerWidth >= 1025) {
                let headerTimeout;
                
                // 鼠标悬停在header上时显示
                if (header) {
                    header.addEventListener('mouseenter', function() {
                        clearTimeout(headerTimeout);
                        header.classList.add('show');
                        if (headerHint) {
                            headerHint.classList.add('header-visible');
                        }
                    });
                    
                    header.addEventListener('mouseleave', function() {
                        headerTimeout = setTimeout(function() {
                            header.classList.remove('show');
                            if (headerHint) {
                                headerHint.classList.remove('header-visible');
                            }
                        }, 300);
                    });
                }
                
                // 鼠标悬停在提示条上时显示header
                if (headerHint) {
                    headerHint.addEventListener('mouseenter', function() {
                        clearTimeout(headerTimeout);
                        if (header) {
                            header.classList.add('show');
                            headerHint.classList.add('header-visible');
                        }
                    });
                    
                    headerHint.addEventListener('mouseleave', function() {
                        headerTimeout = setTimeout(function() {
                            if (header) {
                                header.classList.remove('show');
                                headerHint.classList.remove('header-visible');
                            }
                        }, 300);
                    });
                }
            }
            
            // 旧的点击切换逻辑（非大屏文章页保留）
            function handleHeaderClick() {
                if (!header) return;

                // 在非文章页时不执行隐藏操作
                if (!document.body.classList.contains('is-post')) {
                    return;
                }
                
                // 大屏模式下不使用点击切换
                if (window.innerWidth >= 1025) {
                    return;
                }

                // 小屏模式：点击头部时，切换头部显示/隐藏
                if (header.classList.contains('hidden')) {
                    header.classList.remove('hidden');
                } else {
                    header.classList.add('hidden');
                }
            }
            
            // 监听事件
            if(header){
                header.addEventListener('click', handleHeaderClick);
            }
            
            

            // 设备页面 3D 轮播初始化
            if (document.body.classList.contains('is-use')) {
                const container = document.querySelector('.paper-main');
                if (container) {
                    const deviceCards = Array.from(container.querySelectorAll('.device-card'));
                    if (deviceCards.length > 0) {
                        const carousel = document.createElement('div');
                        carousel.className = 'device-carousel';
                        const track = document.createElement('div');
                        track.className = 'device-carousel-track';

                        // 先把轮播插入到第一个卡片的父级中，位于首个卡片之前
                        const firstCard = deviceCards[0];
                        const parentNode = firstCard.parentNode;
                        if (parentNode) {
                            parentNode.insertBefore(carousel, firstCard);
                        }

                        deviceCards.forEach((card) => {
                            const slide = document.createElement('div');
                            slide.className = 'device-slide';
                            slide.appendChild(card);
                            track.appendChild(slide);
                        });

                        const nav = document.createElement('div');
                        nav.className = 'device-carousel-nav';
                        const prevBtn = document.createElement('button');
                        prevBtn.className = 'device-carousel-btn device-prev';
                        prevBtn.setAttribute('aria-label', '上一项');
                        prevBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        const nextBtn = document.createElement('button');
                        nextBtn.className = 'device-carousel-btn device-next';
                        nextBtn.setAttribute('aria-label', '下一项');
                        nextBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        nav.appendChild(prevBtn);
                        nav.appendChild(nextBtn);

                        const pagination = document.createElement('div');
                        pagination.className = 'device-carousel-pagination';
                        const dots = deviceCards.map(() => {
                            const dot = document.createElement('div');
                            dot.className = 'device-dot';
                            pagination.appendChild(dot);
                            return dot;
                        });

                        const controls = document.createElement('div');
                        controls.className = 'device-carousel-controls';
                        
                        const leftNav = document.createElement('div');
                        leftNav.className = 'device-carousel-nav';
                        leftNav.appendChild(prevBtn);
                        
                        const rightNav = document.createElement('div');
                        rightNav.className = 'device-carousel-nav';
                        rightNav.appendChild(nextBtn);
                        
                        controls.appendChild(leftNav);
                        controls.appendChild(pagination);
                        controls.appendChild(rightNav);

                        carousel.appendChild(track);
                        carousel.appendChild(controls);

                        let current = 0;
                        const total = deviceCards.length;

                        function layout() {
                            const slides = Array.from(track.children);
                            slides.forEach((slide, i) => {
                                const offset = ((i - current + total) % total);
                                let translateX = 0;
                                let translateZ = 0;
                                let rotateY = 0;
                                let zIndex = 0;
                                // 仅显示当前与两侧相邻，共3项
                                if (offset === 0) {
                                    translateX = -50;
                                    translateZ = 120;
                                    rotateY = 0;
                                    zIndex = 3;
                                    slide.classList.add('active');
                                    slide.classList.remove('hidden');
                                    slide.classList.remove('side');
                                } else if (offset === 1) {
                                    translateX = 20;
                                    translateZ = 0;
                                    rotateY = -20;
                                    zIndex = 2;
                                    slide.classList.remove('active');
                                    slide.classList.remove('hidden');
                                    slide.classList.add('side');
                                } else if (offset === total - 1) {
                                    translateX = -120;
                                    translateZ = 0;
                                    rotateY = 20;
                                    zIndex = 2;
                                    slide.classList.remove('active');
                                    slide.classList.remove('hidden');
                                    slide.classList.add('side');
                                } else {
                                    translateX = (offset < total / 2 ? 160 : -240);
                                    translateZ = -120;
                                    rotateY = offset < total / 2 ? -30 : 30;
                                    zIndex = 1;
                                    slide.classList.remove('active');
                                    slide.classList.add('hidden');
                                    slide.classList.remove('side');
                                }
                                slide.style.zIndex = zIndex.toString();
                                slide.style.transform = `translate3d(${translateX}%, 0, ${translateZ}px) rotateY(${rotateY}deg)`;
                            });
                            dots.forEach((dot, i) => { dot.classList.toggle('active', i === current); });
                        }

                        function go(delta) { current = (current + delta + total) % total; layout(); }

                        prevBtn.addEventListener('click', () => go(-1));
                        nextBtn.addEventListener('click', () => go(1));
                        dots.forEach((dot, i) => dot.addEventListener('click', () => { current = i; layout(); }));

                        carousel.setAttribute('tabindex', '0');
                        carousel.addEventListener('keydown', (e) => { if (e.key === 'ArrowLeft') go(-1); if (e.key === 'ArrowRight') go(1); });
                        let startX = 0;
                        carousel.addEventListener('touchstart', (e) => { startX = e.touches[0].clientX; }, { passive: true });
                        carousel.addEventListener('touchend', (e) => {
                            const dx = e.changedTouches[0].clientX - startX;
                            if (dx > 40) go(-1);
                            if (dx < -40) go(1);
                        }, { passive: true });

                        layout();

                        // 点击左右侧卡片切换
                        track.addEventListener('click', (e) => {
                            const slides = Array.from(track.children);
                            const clickedSlide = e.target.closest('.device-slide');
                            if (!clickedSlide) return;
                            const index = slides.indexOf(clickedSlide);
                            if (index === -1) return;
                            const offset = ((index - current + total) % total);
                            if (offset === 1) go(1);
                            if (offset === total - 1) go(-1);
                        });

                        // 禁用非激活卡片的图片点击放大
                        track.addEventListener('click', (e) => {
                            if (e.target.tagName === 'IMG') {
                                const slide = e.target.closest('.device-slide');
                                if (!slide || !slide.classList.contains('active')) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        });
                    }
                }
            }
        });
        </script>
        
        <!-- 异步加载代码高亮 -->
        
        <script async="" src="/js/highlight.min.js"></script>
        <script async="" src="/js/highlightjs-line-numbers.js"></script>
        <script>
        // 等待代码高亮库加载完成后初始化
        function initHighlight() {
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
                hljs.initLineNumbersOnLoad();
            } else {
                setTimeout(initHighlight, 100);
            }
        }
        document.addEventListener('DOMContentLoaded', initHighlight);
        </script>
        
        

        <!-- 异步加载目录功能 -->
        <script async="" src="/js/toc.js"></script>
    
</body></html>