<!DOCTYPE html><html data-theme="dark"><head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport">
  <meta name="robots" content="index, follow">
  <!-- title -->
  
    
  <title>聊聊Java IO的那些事 - 子规入梧桐</title>
    
  
  
  <!-- open graph -->
  <meta name="description" content="BIO NIO AIO    IO模型 同步阻塞 同步非阻塞（多路复用） 异步非阻塞   编程难度 简单 复杂 复杂   可靠性 差 好 好   吞吐量 低 高 高   阅前须知阻塞 IO 和 非阻塞 IO 这两个概念是 程序级别 的。主要描述是程序请求操作系统 IO 操作之后，如果 IO 资源没有准备好，那么程序如何处理问题：前者等待，后者继续执行（并且使用线程一直轮询，直到有 IO 资">
<meta property="og:type" content="article">
<meta property="og:title" content="聊聊Java IO的那些事">
<meta property="og:url" content="https://www.lazydaily.cn/761386768996841/index.html">
<meta property="og:site_name" content="子规入梧桐">
<meta property="og:description" content="BIO NIO AIO    IO模型 同步阻塞 同步非阻塞（多路复用） 异步非阻塞   编程难度 简单 复杂 复杂   可靠性 差 好 好   吞吐量 低 高 高   阅前须知阻塞 IO 和 非阻塞 IO 这两个概念是 程序级别 的。主要描述是程序请求操作系统 IO 操作之后，如果 IO 资源没有准备好，那么程序如何处理问题：前者等待，后者继续执行（并且使用线程一直轮询，直到有 IO 资">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lazydaily.cn/img/acea8af4268c8d552741ccebcb2d34ec_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/0fb77c535fcbf8f4264b6eff292fd210_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/ed84ace61748c9dbdaf3f9718f21ff21_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/a8f0d4502adb087892e11866bdac7d57_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/5ee1af7a6012fd34b62704d5b2867320_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/5cd2995739f1b0e1f4b355a2471c38aa_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/0d87f8ba4e770fbdcd6c6fc61fb84862_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/f6ef08bdd8b4ff67a419bfe9b7dbc0f2_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/94530647a3be7da4d2de055fff8bacaf_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/0b37a3b751ec9aa08efa75ace30e23c4_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/10d0080498aba2649f1c04067965b579_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/37b1874d4aabb48cd6b511cba09fa70b_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/870a39b7312d1d18324d3aefa613ab37_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/3a01157436842562f7f21f8b4c4549d4_MD5.png">
<meta property="og:image" content="https://www.lazydaily.cn/img/2ff37cd0e1f5f734f8d6209396a08897_MD5.png">
<meta property="article:published_time" content="2024-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-20T07:21:35.911Z">
<meta property="article:author" content="z1gui">
<meta property="article:tag" content="java">
<meta property="article:tag" content="IO">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="BIO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lazydaily.cn/img/acea8af4268c8d552741ccebcb2d34ec_MD5.png">
  <!-- canonical -->
  
  <link rel="canonical" href="https://www.lazydaily.cn/761386768996841/">
  
  <!-- Favicon -->
  <link rel="shortcut icon" href="/img/favicon.png">
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/reset.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/markdown.css">

  
<link rel="stylesheet" href="/css/fonts.css">

  
  <!-- 访问量统计脚本 -->
  <script src="/js/visit-counter.js"></script>
  
  <!-- 图片懒加载 -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const lazyImages = document.querySelectorAll('img[data-src]');
      
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            observer.unobserve(img);
          }
        });
      });

      lazyImages.forEach(img => imageObserver.observe(img));
    });
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="子规入梧桐" type="application/atom+xml">
</head>

    <body>
        <!-- 固定工具栏 -->
        <div class="fixed-toolbar">
            <!-- 主题切换按钮 -->
            <div class="theme-toggle" id="themeToggle" title="切换主题">
                <svg class="sun-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="12" cy="12" r="5" stroke="currentColor" stroke-width="2"></circle>
                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
                </svg>
                <svg class="moon-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
            
            
            <!-- 返回主页按钮仅在文章页面显示 -->
            <div class="home-btn" id="homeBtn" title="返回主页">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 9.5L12 3L21 9.5V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V9.5Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"></path>
                    <path d="M9 21V12H15V21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
            
            <!-- 目录切换按钮仅在文章页面显示 -->
            <div class="toc-toggle-btn" id="tocToggleBtn" title="显示目录">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
            
            
            <!-- 返回顶部按钮 -->
            <div class="back-to-top" id="backToTop" title="返回顶部">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 4L4 12H9V20H15V12H20L12 4Z" fill="currentColor"></path>
                </svg>
            </div>
        </div>
        
        <div class="paper">
            <!-- 左侧个人介绍 -->
            <div class="profile-sidebar">
                <div class="profile-card" id="profileCard">
                    <div class="profile-avatar">
                        <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="头像" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iNDAiIGN5PSI0MCIgcj0iNDAiIGZpbGw9IiNlZWVlZSIvPgo8Y2lyY2xlIGN4PSIzMCIgY3k9IjMwIiByPSI0IiBmaWxsPSIjOTk5OTk5Ii8+CjxjaXJjbGUgY3g9IjUwIiBjeT0iMzAiIHI9IjQiIGZpbGw9IiM5OTk5OTkiLz4KPHBhdGggZD0iTTMwIDUwQzMwIDUwIDM1IDU1IDQwIDU1QzQ1IDU1IDUwIDUwIDUwIDUwIiBzdHJva2U9IiM5OTk5OTkiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+Cjwvc3ZnPgo='" data-src="/img/me.jpeg" loading="lazy">
                    </div>
                    <div class="profile-info">
                        <h3 class="profile-name">子规入梧桐</h3>
                        <div class="typewriter-container profile-mood">
                            <span class="typewriter-text" id="typewriter"></span><span class="cursor">|</span>
                        </div>
                        <p class="profile-description">热爱技术，喜欢分享。专注于Java、JavaScript等技术栈，记录学习心得和生活感悟。</p>
                        <div class="profile-stats">
                            <div class="stat-item" id="articleCountItem">
                                <span class="stat-number" id="articleCount">9</span>
                                <span class="stat-label">文章</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number" id="visitCount">0</span>
                                <span class="stat-label">访问</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="paper-main">
                
                    <div class="post-header">
    <ul class="nav">
        
        <li>
            
            <a href="/" class="">主页</a>
        </li>
        
        <li>
            
            <a href="/archives" class="">归档</a>
        </li>
        
        <li>
            
            <a href="/about" class="">关于</a>
        </li>
        
        <li>
            
            <a href="/atom.xml" class="">RSS</a>
        </li>
        
        <li>
            
            <a href="/use" class="">设备</a>
        </li>
        
    </ul>
</div>

                
                <div class="post-main">
    <!-- 阅读进度条 -->
    <div class="reading-progress-bar" id="readingProgressBar"></div>
    
    
        <div class="post-main-title">
            聊聊Java IO的那些事
        </div>
        <div class="post-meta">
            2024-12-01 ｜ 
            
                <a href="/tags/java/"># java</a>
            
                <a href="/tags/IO/"># IO</a>
            
                <a href="/tags/NIO/"># NIO</a>
            
                <a href="/tags/BIO/"># BIO</a>
            
        </div>
        <!-- 圆角分类 -->
        <!-- <div class="tags">
            
                <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
            
        </div> -->
        <div class="post-content-wrapper">
            <div class="post-md">
                <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">BIO</th>
<th align="center">NIO</th>
<th align="center">AIO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IO模型</td>
<td align="center">同步阻塞</td>
<td align="center">同步非阻塞（多路复用）</td>
<td align="center">异步非阻塞</td>
</tr>
<tr>
<td align="center">编程难度</td>
<td align="center">简单</td>
<td align="center">复杂</td>
<td align="center">复杂</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">差</td>
<td align="center">好</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">吞吐量</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h1 id="阅前须知"><a href="#阅前须知" class="headerlink" title="阅前须知"></a>阅前须知</h1><p><code>阻塞 IO</code> 和 <code>非阻塞 IO</code></p>
<p>这两个概念是 <code>程序级别</code> 的。主要描述是程序请求操作系统 IO 操作之后，如果 IO 资源没有准备好，那么程序如何处理问题：前者等待，后者继续执行（并且使用线程一直轮询，直到有 IO 资源准备好）</p>
<p><code>同步 IO </code> 和 <code>非同步IO</code></p>
<p>这两个概念是<code>操作系统级别</code>的。主要描述的是操作系统在收到程序请求 IO 操作后，如果 IO 资源没有准备好，该如何相应程序的问题：前者不响应，后者返回一个标记，当 IO 资源准备好之后，在用事件机制返回给程序。</p>
<h1 id="一、BIO（Blocking-I-O）"><a href="#一、BIO（Blocking-I-O）" class="headerlink" title="一、BIO（Blocking I/O）"></a>一、BIO（Blocking I/O）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java BIO：同步并阻塞（传统阻塞性），应用程序中进程在发起 IO 调用后至内核执行 IO 操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次 IO 操作为阻塞 IO。阻塞 IO 简称 BIO，Blocking IO。</p>
<p>以前大多数网络通信方式都是阻塞模式，即：</p>
<ul>
<li>客户端向服务器端发送请求后，客户端会一直等待（不会再做其他事情），直到服务器端返回结果或者网络出现问题。</li>
<li>服务端同样的，当在处理某个客户端 A 发来的请求是，另一个客户端 B 发来的请求会等待，直到服务器端的这个处理线程完成上个处理。</li>
</ul>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/acea8af4268c8d552741ccebcb2d34ec_MD5.png" loading="lazy"></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><ol>
<li>服务器启动一个 ServerSocket。</li>
<li>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<pre><code class="language-java">package com.atguigu.bio;

import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class BIOServer {
    
    public static void main(String[] args) throws Exception {
        //线程池机制
        //思路
        //1. 创建一个线程池
        //2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)
        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
        //创建ServerSocket
        ServerSocket serverSocket = new ServerSocket(6666);
        System.out.println("服务器启动了");
        while (true) {
            System.out.println("线程信息id = " + Thread.currentThread().getId() + "名字 = " + Thread.currentThread().getName());
            //监听，等待客户端连接
            System.out.println("等待连接....");
            //会阻塞在accept()
            final Socket socket = serverSocket.accept();
            System.out.println("连接到一个客户端");
            //就创建一个线程，与之通讯(单独写一个方法)
            newCachedThreadPool.execute(new Runnable() {
                public void run() {//我们重写
                    //可以和客户端通讯
                    handler(socket);
                }
            });
        } 
    }
    
    //编写一个handler方法，和客户端通讯
    public static void handler(Socket socket) {
        try {
            System.out.println("线程信息id = " + Thread.currentThread().getId() + "名字 = " + Thread.currentThread().getName());
            byte[] bytes = new byte[1024];
            //通过socket获取输入流
            InputStream inputStream = socket.getInputStream();
            //循环的读取客户端发送的数据
            while (true) {
                System.out.println("线程信息id = " + Thread.currentThread().getId() + "名字 = " + Thread.currentThread().getName());
                System.out.println("read....");
                int read = inputStream.read(bytes);
                if (read != -1) {
                    System.out.println(new String(bytes, 0, read));//输出客户端发送的数据
                } else {
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("关闭和client的连接");
            try {
                socket.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>传统的 IO 模型，其主要是一个 Server 对接 N 个客户端，在客户端连接之后，为每个客户端分配一个子线程。如图所示：</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/0fb77c535fcbf8f4264b6eff292fd210_MD5.png" loading="lazy"></p>
<p>从图中可以看出，传统 IO 的特点在于：</p>
<ul>
<li>每个客户端连接到达时，服务端会分配一个线程给该客户端，该线程处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程</li>
<li>同一时刻，服务端的吞吐量与服务器所提供的线程数量呈线性关系的。</li>
</ul>
<p>如果并发量不大，运行没有问题，但是如果海量并发时候，就会出现问题：</p>
<ol>
<li>每次请求都要创建独立的线程，与对应的客户端进行数据的Read，业务处理，数据Write、</li>
<li>当并发数较大时，需要创建大量线程处理连接，资源占用较大。</li>
<li>连接建立后，如果当前线程展示没有数据可读，则线程就阻塞在Read操作上，造成线程资源浪费。</li>
</ol>
<h2 id="改进：多线程方式-伪异步方式"><a href="#改进：多线程方式-伪异步方式" class="headerlink" title="改进：多线程方式 - 伪异步方式"></a>改进：多线程方式 - 伪异步方式</h2><p>上述说的情况只是服务器只有一个线程的情况，那么如果引入多线程是不是可以解决这个问题：</p>
<ul>
<li>当服务器收到客户端 X 的请求后，（读取到所有的请求数据后）将这个请求送入到一个独立线程进行处理，然后主线程继续接收客户端 Y 的请求。</li>
<li>客户端侧，也可以用一个子线程和服务器端进行通信。这样客户端主线程的其他工作不受影响，当服务器有响应信息时候再有这个子线程通过 <code>监听模式/观察模式</code>（等其他设计模式）通知主线程。</li>
</ul>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/ed84ace61748c9dbdaf3f9718f21ff21_MD5.png" loading="lazy"></p>
<p>但是多线程解决这个问题有局限性：</p>
<ul>
<li>操作系统通知accept() 的方式还是单个，即：服务器收到数据报文之后的“业务处理过程”可以多线程，但是报文的接收还是需要一个个来</li>
<li>在操作系统中，线程是有限的。线程越多，CPU 切换所需时间也越长，用来处理真正业务的需求也就越少。</li>
<li>创建线程需要较大的资源消耗。JVM 创建一个线程，即使不进行任何工作，也需要分配一个堆栈空间（128k）。</li>
<li>如果程序中使用了大量的长连接，线程是不会关闭的，资源消耗更容易失控。</li>
</ul>
<blockquote>
<p>为啥 <code>serverSocket. accept()</code> 会出现阻塞？</p>
</blockquote>
<p>是因为 Java 通过 JNI 调用的系统层面的 <code>accept0()</code> 方法，<code>accept0()</code> 规定如果发现套间字从指定的端口来，就会等待。其实就是内部实现是操作系统级别的同步 IO。</p>
<h1 id="二、NIO（non-Blocking-I-O）"><a href="#二、NIO（non-Blocking-I-O）" class="headerlink" title="二、NIO（non-Blocking I/O）"></a>二、NIO（non-Blocking I/O）</h1><p>了解 NIO 之前我们先来看看标准 I/O（Standard I/O）。</p>
<p>Standard I/O 是对字节的读写，在进行 I/O 之前，首先创建一个流对象，流对象的读写操作都是按字节，一个字节一个字节的读或者写。而 NIO 把 I/O 抽象成块，类似磁盘的读写，每次 I/O 操作的单位都是一个块，块被读入内存之后就是一个 <code> byte[]</code>，NIO 一次可以读或者写多个字节。</p>
<h2 id="流和块"><a href="#流和块" class="headerlink" title="流和块"></a>流和块</h2><p>IO 和 NIO 最重要的区别就是对数据的打包和传输的方式，IO 是以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 IO 一次性处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 IO 通常处理非常慢。</p>
<p>面向块的 I/O 一次性处理一个数据块：按块处理数据比按流处理数据要快的多，但是面向块的 I/O 确实一些面向流的 I/O 所具有的优雅和简单。</p>
<p>I/O 包和 NIO 已经很好的集成了，<code>java.io.*</code> 中已经以 NIO 重新实现了，可以利用一些 NIO 的特性。例如：在 <code>java.io.*</code> 中某些类包含以块的形式读写数据的操作，这使得及时在面向流的系统中，处理数据也会更快。</p>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮训到连接有 I/O 请求就进行处理。</p>
<p><strong>核心概念：</strong></p>
<ol>
<li><strong>三大核心：</strong> Channel（通道）、Buffer（缓冲区）、Selector（选择器）。</li>
<li><strong>面向缓冲区，或者是面向块编程。</strong> 数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩弹性网络。</li>
<li><strong>非阻塞模式</strong>， 使一个线程从某个通道发送请求或者读取数据，但是他仅能得到目前可用的数据，如果目前没有数据可用，就什么都不会获取，而不是保持线程阻塞。所以知道数据变得可读取之前，该线程还可以去做其他实行。</li>
<li><strong>Channel 和 Buffer 一一对应。</strong></li>
<li><strong>一个线程只有一个 Selector，一个线程对应对个 Channel（连接）</strong>。</li>
<li>程序切换到哪个 Channel 是由事件决定，Event 就是个重要概念。</li>
<li>Selector 会根据不同的事件，在各个通道上切换。</li>
<li><strong>Buffer 是一个内存块，底层就是一个数组</strong>。</li>
<li>数据读写都是通过 Buffer，区别于 BIO 的输入输出流，且<strong>双向</strong>，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的 。</li>
</ol>
<h2 id="编程原理"><a href="#编程原理" class="headerlink" title="编程原理"></a>编程原理</h2><ol>
<li>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel。</li>
<li>Selector 进行监听 select 方法，返回有事件发生的通道个数。</li>
<li>将 SocketChannel 注册到 Selector 上（<code>register(Selector selector, int ops)</code>），一个 Selector 可以注册多个 SocketChannel。</li>
<li>注册后返回 SelectionKey，会和该 Selector 关联（集合）。</li>
<li>当有事件发生时，进一步得到各个 SelectionKey。</li>
<li>通过channel () 方法，用 SelectionKey 反向获取 SocketChannel。</li>
<li>可以通过得到的 channel，完成业务处理。</li>
</ol>
<h2 id="1-缓冲区（Buffer）"><a href="#1-缓冲区（Buffer）" class="headerlink" title="1. 缓冲区（Buffer）"></a>1. 缓冲区（Buffer）</h2><h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h3><p><code>ByteBuffer</code> 字节数据；<code>ShortBuffer</code> 字符串数据；<code>CharBuffer</code> 字符数据；<code>IntBuffer</code> 整数；<code>LongBuffer</code> 长整数；<code>DoubleBuffer</code> 小数；<code>FloatBuffer</code> 小数</p>
<h3 id="Buffer-属性和方法"><a href="#Buffer-属性和方法" class="headerlink" title="Buffer 属性和方法"></a>Buffer 属性和方法</h3><p>Buffer 类提供了 4 个属性来提供数据元素信息：<code>capacity（容量）</code>：缓存区的最大容量，<code>Limit（终点）</code>：缓存区最大可操作位置，<code>Position（位置）</code> ：缓存区当前在操作的位置，<code>Mark（标记）</code>：标记位置</p>
<pre><code class="language-java">public abstract class Buffer{
	public final int capacity();
	public final int position();
	public final Buffer position(int newPosition);
	public final int limit();
	public final Buffer limit(int newLimit);
	
}
//其中比较常用的就是ByteBuffer（二进制数据），该类主要有以下方法
public abstract class ByteBuffer(){
	public static ByteBuffer allocateDirect(int capacity);//直接创建缓冲区
	public static ByteBuffer allocate(int capacity);//设置缓冲区的初始容量
	public static ByteBuffer wrap(byte[] array);//把一个数组放入到缓冲区使用
	//构造初始化位置offset和上界length的缓冲区
	public static ByteBuffer wrap(byte[] array,int offset,int length);
	//缓冲区读取相关API
	public abstract byte get();//从当前位置position上get，get之后，positon会+1
	public abstract byte get(int index);//从绝对位置获取
	public abstract ByteBuffer put(byte b);//当前位置上put，put之后，position会+1
	public abstract ByteBuffer put(int index,byte b);//从绝对位置put	
}
</code></pre>
<p>状态变量的改变过程举例:</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/a8f0d4502adb087892e11866bdac7d57_MD5.png" loading="lazy"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/5ee1af7a6012fd34b62704d5b2867320_MD5.png" loading="lazy"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/5cd2995739f1b0e1f4b355a2471c38aa_MD5.png" loading="lazy"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/0d87f8ba4e770fbdcd6c6fc61fb84862_MD5.png" loading="lazy"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/f6ef08bdd8b4ff67a419bfe9b7dbc0f2_MD5.png" loading="lazy"></p>
<h3 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h3><p>以下展示了使用 NIO 快速复制文件的实例：</p>
<pre><code class="language-java">public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);
        
        /* 清空缓冲区 */
        buffer.clear();
    }
}
</code></pre>
<h2 id="2-通道（Channel）"><a href="#2-通道（Channel）" class="headerlink" title="2. 通道（Channel）"></a>2. 通道（Channel）</h2><p>通道类似流，但是有如下区别：</p>
<ul>
<li>通道可以同时读写，而流只能读或写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲区读数据，也可以写数据到缓冲区</li>
</ul>
<h3 id="通道分类"><a href="#通道分类" class="headerlink" title="通道分类"></a>通道分类</h3><p>Channel 在 NIO 中是一个接口 <code>public interface Channle extends Closeable{}</code>。其中，常用的 Channel 类有：</p>
<ol>
<li><code>FileChannel</code>：用于文件的数据读写；</li>
<li><code>DatagramChannel</code>：用于 UDP 的数据读写；</li>
<li><code>ServerSocketChannel</code>：可以监听新来的连接，对每一个新进来的连接都会创建一个 SocketChannel。只有通过这个通道，应用程序才能箱操作系统注册支持“多路复用 IO”的端口减轻。支持 TCP 和 UDP 协议；</li>
<li><code>SocketChannel</code>：TCP Socket 套接字的监听通道，用于 TCP 的数据读写</li>
<li>其他的通道包括：</li>
</ol>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/94530647a3be7da4d2de055fff8bacaf_MD5.png" loading="lazy"></p>
<h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p>对本地文件进行 IO 操作，常用方法及实例应用：</p>
<pre><code class="language-java">//从通道读取数据并放到缓冲区内
public int read(ByteBuffer content);
//从缓冲区写数据到通道中
public int write(ByteBuffer content);
//从目标通道中复制数据到当前通道内
public long transferFrom(ReadableByteChannel src,long position,long count);
//把数据从当前通道复制到目标通道
public long transferTo(long position,long count,WritabelByteChannel target);
</code></pre>
<p>1 . 写入文件，使用之前 <code>ByteBuffer</code> 和 <code>FileChannel</code> 类</p>
<pre><code class="language-java">//使用之前ByteBuffer和FileChannel类，写入文件
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class NIOFileChannel{
	public static void main(String[] args) throws Exception{
		String str = "hello,world";
		//创一个输出流 -&gt; channel
		FileOutputStream stream = new FileOutputStream("d:\\file.txt");
		//通过 stream 获取对应的 FileChannel
		//这个 fileChannel 真实类型是 FileChannelImpl
		FileChannel fileChannel = stream.getChannel();

		//创建一个缓冲区 ByteBuffer
		ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
		//将 str 放入到缓冲区
		byteBuffer.put(str.getBytes());
		//对 byteBuffer 进行 flip
		byteBuffer.flip();

		//将 byteBuffer 写入到 fileChannel
		fileChannel.write(byteBuffer);
		fileOutputStream.close();
	}

}
</code></pre>
<p>2 . 读取文件数据并展示，使用之前 <code>ByteBuffer</code> 和 <code>FileChannel</code> 类</p>
<pre><code class="language-java">//读取本地文件
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class NIOFileChannel{
	public static void main(String[] args) throws Exception{
		//创一个输出流 -&gt; channel
		File file = new File("d:\\file.txt");
		FileOutputStream stream = new FileOutputStream(file);
		//通过 stream 获取对应的 FileChannel
		//这个 fileChannel 真实类型是 FileChannelImpl
		FileChannel fileChannel = stream.getChannel();

		//创建一个缓冲区 ByteBuffer
		ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());

		//将 byteBuffer 写入到 fileChannel
		fileChannel.read(byteBuffer);
		//将 byteBuffer的字节转化成String
		System.out.println(new String(byteBuffer.array()));
		fileOutputStream.close();
	}

}
</code></pre>
<p>3 . 使用一个 <code>Buffer</code> 完成文件的读取、写入</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class NIOFileChannel03 {

    public static void main(String[] args) throws Exception {

        FileInputStream fileInputStream = new FileInputStream("1.txt");
        FileChannel fileChannel01 = fileInputStream.getChannel();
        FileOutputStream fileOutputStream = new FileOutputStream("2.txt");
        FileChannel fileChannel02 = fileOutputStream.getChannel();

        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        
        while (true) { //循环读取

            //这里有一个重要的操作，一定不要忘了
            /*
            public final Buffer clear() {
                position = 0;
                limit = capacity;
                mark = -1;
                return this;
            }
            */
            byteBuffer.clear(); //清空 buffer
            int read = fileChannel01.read(byteBuffer);
            System.out.println("read = " + read);
            if (read == -1) { //表示读完
                break;
            }

            //将 buffer 中的数据写入到 fileChannel02--2.txt
            byteBuffer.flip();
            fileChannel02.write(byteBuffer);
        }

        //关闭相关的流
        fileInputStream.close();
        fileOutputStream.close();
    }
}
</code></pre>
<p>4 . 拷贝文件transferFrom 方法</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.channels.FileChannel;

public class NIOFileChannel04 {

    public static void main(String[] args) throws Exception {

        //创建相关流
        FileInputStream fileInputStream = new FileInputStream("d:\\a.jpg");
        FileOutputStream fileOutputStream = new FileOutputStream("d:\\a2.jpg");
        
        //获取各个流对应的 FileChannel
        FileChannel sourceCh = fileInputStream.getChannel();
        FileChannel destCh = fileOutputStream.getChannel();

        //使用 transferForm 完成拷贝
        destCh.transferFrom(sourceCh, 0, sourceCh.size());

        //关闭相关通道和流
        sourceCh.close();
        destCh.close();
        fileInputStream.close();
        fileOutputStream.close();
    }
}
</code></pre>
<h3 id="Buffer-和-Channel-注意事项"><a href="#Buffer-和-Channel-注意事项" class="headerlink" title="Buffer 和 Channel 注意事项"></a>Buffer 和 Channel 注意事项</h3><p><strong>1. ByteBuffer 支持类型化的 put 和 get，put 放什么，get 取出什么，不然出现 BufferUnderflowException 异常</strong></p>
<pre><code class="language-java">import java.nio.ByteBuffer;

public class NIOByteBufferPutGet {

    public static void main(String[] args) {
        
        //创建一个 Buffer
        ByteBuffer buffer = ByteBuffer.allocate(64);

        //类型化方式放入数据
        buffer.putInt(100);
        buffer.putLong(9);
        buffer.putChar('尚');
        buffer.putShort((short) 4);

        //取出
        buffer.flip();
        
        System.out.println();
        
        System.out.println(buffer.getInt());
        System.out.println(buffer.getLong());
        System.out.println(buffer.getChar());
        System.out.println(buffer.getShort());
    }
}
</code></pre>
<p><strong>2. 普通 Buffer 转成只读 Buffer</strong></p>
<pre><code class="language-java">
import java.nio.ByteBuffer;

public class ReadOnlyBuffer {

    public static void main(String[] args) {

        //创建一个 buffer
        ByteBuffer buffer = ByteBuffer.allocate(64);

        for (int i = 0; i &lt; 64; i++) {
            buffer.put((byte) i);
        }

        //读取
        buffer.flip();

        //得到一个只读的 Buffer
        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();
        System.out.println(readOnlyBuffer.getClass());

        //读取
        while (readOnlyBuffer.hasRemaining()) {
            System.out.println(readOnlyBuffer.get());
        }

        readOnlyBuffer.put((byte) 100); //ReadOnlyBufferException
    }
}
</code></pre>
<p><strong>3. NIO 中 MappedByteBuffer，可以让文件直接在堆外内存修改</strong></p>
<pre><code class="language-java">
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

/**
 * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次
 */
public class MappedByteBufferTest {

    public static void main(String[] args) throws Exception {

        RandomAccessFile randomAccessFile = new RandomAccessFile("1.txt", "rw");
        //获取对应的通道
        FileChannel channel = randomAccessFile.getChannel();

        /**
         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式
         * 参数 2：0：可以直接修改的起始位置
         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存
         * 可以直接修改的范围就是 0-5
         * 实际类型 DirectByteBuffer
         */
        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);

        mappedByteBuffer.put(0, (byte) 'H');
        mappedByteBuffer.put(3, (byte) '9');
        mappedByteBuffer.put(5, (byte) 'Y');//IndexOutOfBoundsException

        randomAccessFile.close();
        System.out.println("修改成功~~");
    }
}
</code></pre>
<ol start="4">
<li><strong>NIO 还支持通过多个 Buffer（即 Buffer数组）完成读写操作，即 Scattering 和 Gathering</strong></li>
</ol>
<pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Arrays;

/**
 * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]
 * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读
 */
public class ScatteringAndGatheringTest {

    public static void main(String[] args) throws Exception {
        
        //使用 ServerSocketChannel 和 SocketChannel 网络
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);

        //绑定端口到 socket，并启动
        serverSocketChannel.socket().bind(inetSocketAddress);

        //创建 buffer 数组
        ByteBuffer[] byteBuffers = new ByteBuffer[2];
        byteBuffers[0] = ByteBuffer.allocate(5);
        byteBuffers[1] = ByteBuffer.allocate(3);

        //等客户端连接 (telnet)
        SocketChannel socketChannel = serverSocketChannel.accept();

        int messageLength = 8; //假定从客户端接收 8 个字节

        //循环的读取
        while (true) {
            int byteRead = 0;

            while (byteRead &lt; messageLength) {
                long l = socketChannel.read(byteBuffers);
                byteRead += l; //累计读取的字节数
                System.out.println("byteRead = " + byteRead);
                //使用流打印,看看当前的这个 buffer 的 position 和 limit
                Arrays.asList(byteBuffers).stream().map(buffer -&gt; "position = " + buffer.position() + ", limit = " + buffer.limit()).forEach(System.out::println);
            }

            //将所有的 buffer 进行 flip
            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());
            //将数据读出显示到客户端
            long byteWirte = 0;
            while (byteWirte &lt; messageLength) {
                long l = socketChannel.write(byteBuffers);//
                byteWirte += l;
            }
            
            //将所有的buffer进行clear
            Arrays.asList(byteBuffers).forEach(buffer -&gt; {
                buffer.clear();
            });
            
            System.out.println("byteRead = " + byteRead + ", byteWrite = " + byteWirte + ", messagelength = " + messageLength);
        }
    }
}
</code></pre>
<h2 id="3-Selector（选择器）"><a href="#3-Selector（选择器）" class="headerlink" title="3. Selector（选择器）"></a>3. Selector（选择器）</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。NIO 实现了 IO 多路复用中的 Reator 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个 Channel 上的事件，从而让一个线程能够处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入到阻塞状态一直等待，而是鸡血轮询其他 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>以为创建和切换线程的开销很大，因此使用一个线程处理多个事件显然比一个线程处理一个事件具有更好的性能。</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/0b37a3b751ec9aa08efa75ace30e23c4_MD5.png" loading="lazy"></p>
<ol>
<li>Java 中的 NIO 可以用一个线程，处理多个客户端连接，就会使用到 Selector（选择器）</li>
<li>多个 Channel 以事件的方式注册到 Selector</li>
<li>只有在连接通道有真正的读写事件的时候，才会进行读写，减少系统开销</li>
<li>避免了<code>多线程之间的上下文切换导致的开销</code></li>
</ol>
<pre><code class="language-java">//Selector 类是一个抽象类，常用方法和说明如下：
public abstract class Selector implements Closeable{
	public static Selector open();//监控所有注册的通道，当其中有IO操作可以进行时，将SelectionKey加入到内部的集合中并返回，参数用来设置超时时间
	public Set&lt;SelectionKey&gt; selectedKey();//从内部集合中得到所有的SelectionKey	
}
</code></pre>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><strong>创建选择器</strong></li>
</ol>
<pre><code class="language-java">Selector selector = Selector.open();
</code></pre>
<ol start="2">
<li><strong>将通道注册到选择器上</strong></li>
</ol>
<pre><code class="language-java">ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector,SelectionKey.OP_ACCEPT);
</code></pre>
<p>将通道注册到选择器上，还需要指定要注册的具体事件，主要有以下几类：</p>
<p><code>SelectionKey. OP_CONNECT</code>、<code>SelectionKey. OP_ACCEPT</code>、<code>SelectionKey. OP_READ</code>、 <code>SelectionKey. OP_WRITE</code></p>
<p>他们在 SelectionKey 的定义如下：</p>
<pre><code class="language-java">public static final int OP_READ = 1 &lt;&lt; 0;
public static final int OP_WRITE = 1 &lt;&lt; 2;
public static final int OP_CONNECT = 1 &lt;&lt; 3;
public static final int OP_ACCEPT = 1 &lt;&lt; 4;
</code></pre>
<p>可以看出每个事件都能当成一个位域，从而组成事件集整数。例如：</p>
<pre><code class="language-java">int intersetSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>
<ol start="3">
<li><strong>监听事件</strong></li>
</ol>
<pre><code class="language-java">int num = selector.select();
</code></pre>
<p>使用 <code>select()</code> 方法来监听到达的事件，它会一直阻塞知道有至少一件事件到达。</p>
<ol start="4">
<li><strong>获取到达的事件</strong></li>
</ol>
<pre><code class="language-java">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
while(keyIterator.hasNext()){
	SelectionKey keyu = keyIterator.next();
	if(key.isAcceptabnle()){
	// ...
	}else if(key.isReadable()){
	// ...
	}
	keyIterator.remove();
}
</code></pre>
<ol start="5">
<li><strong>时间循环</strong></li>
</ol>
<p>因为一次 select() 调动不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理时间的代码一般会放在一个死循环内。</p>
<pre><code class="language-java">while (true) { 
	int num = selector.select(); 
	Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); 
	Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); 
	while (keyIterator.hasNext()) { 
		SelectionKey key = keyIterator.next(); 
		if (key.isAcceptable()) { 
		  // ... 
		} else if (key.isReadable()) {
		  // ... 
		} 
		keyIterator.remove(); 
	}
}
</code></pre>
<h3 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h3><pre><code class="language-java">public class NIOServer {
 	public static void main(String[] args) throws IOException {
		Selector selector = Selector.open();
		ServerSocketChannel ssChannel = ServerSocketChannel.open();
		ssChannel.configureBlocking(false);
		ssChannel.register(selector, SelectionKey.OP_ACCEPT);
		ServerSocket serverSocket = ssChannel.socket();
		InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
		serverSocket.bind(address);
		while(true){
			selector.select();
			Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
			Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
			while (keyIterator.hasNext()){
				SelectionKey key = keyIterator.next();
				if (key.isAcceptable()) {
					ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();// 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept();
					sChannel.configureBlocking(false);// 这个新连接主要用于从客户端读取数据 
					sChannel.register(selector, SelectionKey.OP_READ);
				}else if (key.isReadable()) {
					SocketChannel sChannel = (SocketChannel) key.channel();
					System.out.println(readDataFromSocketChannel(sChannel));
					sChannel.close();
				}
 			keyIterator.remove();
			}
		}
 	}
	private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {
		ByteBuffer buffer = ByteBuffer.allocate(1024);
		StringBuilder data = new StringBuilder();
		while(true) {
			buffer.clear();
			int n = sChannel.read(buffer);
			if (n == -1) {
				break;
			}
			buffer.flip();
			int limit = buffer.limit();
			char[] dst = new char[limit];
			for (int i = 0;i &lt; limit;i++) {
				dst[i] = (char) buffer.get(i);
			}
			data.append(dst);
			buffer.clear();
 		}
 		return data.toString();
 	}
 }
</code></pre>
<pre><code class="language-java">public class NIOClient {
	public static void main(String[] args) throws IOException{
		Socket socket = new Socket("127.0.0.1"，8888);
		OutputStream out = socket.getOutputStream();
		String s = "hello world";
		out.write(s.getBytes());
		out.close();
	}
}
</code></pre>
<h2 id="典型的多路复用-IO-实现"><a href="#典型的多路复用-IO-实现" class="headerlink" title="典型的多路复用 IO 实现"></a>典型的多路复用 IO 实现</h2><p>目前流程的多路复用 IO 实现主要宝库了四种：select、poll、epoll、kqueue。以下是其特性及区别：</p>
<table>
<thead>
<tr>
<th align="center">IO 模型</th>
<th align="center">相对性能</th>
<th align="center">关键思路</th>
<th align="center">操作系统</th>
<th align="center">Java 支持情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">较高</td>
<td align="center">Reactor</td>
<td align="center">Win/Linux</td>
<td align="center">支持，Reactor 模式（反应器设计模式）。Linux kernels 2.4 内核版本之前，默认用的是 select ；目前 windows 下对吧同步 IO 的支持，都是 select 模型</td>
</tr>
<tr>
<td align="center">poll</td>
<td align="center">较高</td>
<td align="center">Reactor</td>
<td align="center">Linux</td>
<td align="center">Linux 下的 Java 的 NIO 框架，Linux kernels 2.6 内核版本之前使用 poll 进行支持。也是使用的 Reactor 模式</td>
</tr>
<tr>
<td align="center">epoll</td>
<td align="center">高</td>
<td align="center">Reactor/Proactor</td>
<td align="center">Linux</td>
<td align="center">Linux kernels 2.6 内核版本之后使用 epoll 进行支持</td>
</tr>
<tr>
<td align="center">kqueue</td>
<td align="center">高</td>
<td align="center">Proactor</td>
<td align="center">Linux</td>
<td align="center">目前 Java 版本不支持</td>
</tr>
</tbody></table>
<h3 id="1-Reactor事件驱动模型"><a href="#1-Reactor事件驱动模型" class="headerlink" title="1. Reactor事件驱动模型"></a>1. Reactor事件驱动模型</h3><p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/10d0080498aba2649f1c04067965b579_MD5.png" loading="lazy"></p>
<p>从图上可知：一个完整的 Reactor 事件驱动模型是有四个部分组成：客户端 Client，Reactor，Acceptor 和时间处理 Handler。其中 Acceptor 会不间断的接收客户端的连接请求，然后通过 Reactor 分发到不同 Handler 进行处理。改进后的 Reactor 有如下优点：</p>
<ul>
<li>虽然同是由一个线程接收连接请求进行网络读写，但是 Reactor 将客户端连接，网络读写，业务处理三大部分拆分，从而极大提高工作效率。</li>
<li>Reactor 是以事件驱动的，相比传统 IO 阻塞式的，不必等待，大大提升了效率。</li>
</ul>
<h3 id="2-Reactor-模型——业务处理和-IO-分离"><a href="#2-Reactor-模型——业务处理和-IO-分离" class="headerlink" title="2. Reactor 模型——业务处理和 IO 分离"></a>2. Reactor 模型——业务处理和 IO 分离</h3><p>在上面的处理模型中，由于网络读写是在同一个线程里面。在高并发情况下，会出现两个瓶颈：</p>
<ul>
<li>高频率的读写事件处理</li>
<li>大量的业务处理</li>
</ul>
<p>基于上述瓶颈，可以将业务处理和 IO 读写分离出来：</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/37b1874d4aabb48cd6b511cba09fa70b_MD5.png" loading="lazy"></p>
<p>如图可以看出，相对基础 Reactor 模型，该模型有如下特点：</p>
<ul>
<li>使用一个线程进行客户端连接和网络读写</li>
<li>客户端连接之后，将该连接交给线程池进行加解码以及业务处理</li>
</ul>
<p>这种模型在接收请求进行网络读写的同时，也在进行业务处理，大大提高了系统的吞吐量。但是也有不足的地方：</p>
<ul>
<li>网络读写是一个比较消耗 CPU 的操作，在高并发的情况下，将有大量的客户端需要网络读写，此时一个线程处理不了这么多的请求。</li>
</ul>
<h3 id="3-Reactor——并发读写"><a href="#3-Reactor——并发读写" class="headerlink" title="3. Reactor——并发读写"></a>3. Reactor——并发读写</h3><p>由于高并发的网络读写是系统一个瓶颈，所以针对这种情况，改进了模型，如图所示：</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/870a39b7312d1d18324d3aefa613ab37_MD5.png" loading="lazy"><br>由图可以看出，在原有 Reactor 模型上，同时将 Reactor 拆分成 mainReactor 和 subReactor 。其中 mainReactor 主要负责客户端的请求连接，subReactor 通过一个线程池进行支撑，主要负责网络读写，因为线程池的原因，可以进行多线程并发读写，大大提升了网络读写的效率。业务处理也是通过线程池进行。通过这种方式，可以进行百万级别的连接。</p>
<h3 id="4-Reactor-模型示例"><a href="#4-Reactor-模型示例" class="headerlink" title="4. Reactor 模型示例"></a>4. Reactor 模型示例</h3><p>对于上述的 Reactor 模型，主要有三个核心需要实现：Acceptor，Reactor 和 Handler。具体实现代码如下：</p>
<pre><code class="language-java">public class Reactor implements Runnable{
	private final Selector selector;
	private final ServerSocketChannel serverSocket;

	public Reactor(int port) throws IOException{
		serverSocket = ServerSocketChannel.open();//创建服务端的ServerSocketChannel
		serverSocket.configureBlocking(false);//设置为非阻塞模式
		selector = Selector.open();//创建一个selector选择器
		SelectionKey key = serverSocket.register(selector,SelectionKey.OP_ACCEPT);
		serverSocket.bind(new InetSocketAddress(port));//绑定服务端端口
		key.attach(new Acceptor(serverSocket));//为服务端Channel绑定一个Acceptor
	}
	@Override
	public void run(){
		try{
			while(！Thread.interrupted()){
				selector.select();//服务端使用一个线程不停接收连接请求
				Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
				Iterator&lt;SelectionKey&gt; itetrator = keys.iterator();
				while(iterator.hasNext()){
					dispatch(iterator.next());
					iterator.remove();
					}
				selector.selectNow();
				}
		}catch(IOException e){
			e.printStackTrace();
		}
	}

	private void dispatch(SelectionKey key) throws IOException{
		//这里的attachment也即前面的为服务端Channel绑定的Acceptor，调用其run()方法进行分发
		Runnable attachment = (Runable)key.attachment();
		attachment.run();
	}

}
</code></pre>
<p>这里Reactor首先开启了一个ServerSocketChannel，然后将其绑定到指定的端口，并且注册到了一个多路复用器上。接着在一个线程中，其会在多路复用器上等待客户端连接。当有客户端连接到达后，Reactor就会将其派发给一个Acceptor，由该Acceptor专门进行客户端连接的获取。下面我们继续看一下Acceptor的代码：</p>
<pre><code class="language-java">public class Acceptor implements Runnable{
	private final ExecuteorService executor = Exxcutors.newFixedThreadPool(20);

	private final ServerSocketChannel serverSocket;

	public Acceptor(ServerSocketChannel serverSocket){
		this.serverSocket = serverSocket;
		}

	@Override
	public void run(){
		try{
			SocketChannel channel = serverSocket.accept();
			if(null != channel){
				executor.execute(new Handler(channel));
			}
		}catch(IOException e){
			e.printStackTrace();
		}
	}
}
</code></pre>
<p>这里可以看到，在Acceptor获取到客户端连接之后，其就将其交由线程池进行网络读写了，而这里的主线程只是不断监听客户端连接事件。下面我们看看Handler的具体逻辑：</p>
<pre><code class="language-java">public class Handler implements Runnable{
	private volatile static Selector selector;
	private final SocketChannel channel;
	private SelectionKey key;
	private volatile ByteBuffer input = ByteBuffer.allocate(1024);
	private volatile ByteBuffer output = ByteBuffer.allocate(1024);

	public Handle(SocketChannel channel) throws IOException{
		this.channel = channel;
		channel.configureBlocking(false);//设置客户端连接为非阻塞模式
		selector = Selector.open();//为客户端创建一个选择器
		key = channel.register(selector,SelectionKey.OP_READ);//注册客户端Channel的读事件	
	}

	@Override
	public void run(){
		try{
			while(selector.isOpen() &amp;&amp; channel.isOpen()){
			 	Set&lt;SelectionKey&gt; keys = select();//等待客户端事件发生
			 	Iterator&lt;SelectionKey&gt; iterator = keys.iterator();
				while(iterator.hasNext()){
					SelectionKey key = iterator.next();
					iterator.remove();

					//如果当前是读事件，则读取数据
					if(key.isReadable()){
						read(key);
					}else if(key.isWritable()){
						write(key)
					}
				}
			}	
		}catch(IOException e){
		e.printStackTrace();
		}
	}
	//读取客户端发送的数据

	private void read(SelectionKey key) throws IOException{
		channel.read(input);
		if(input.position() == 0){
			return ;
		}
		input.flip();
		process();//对读数据进行业务处理
		input.clear();
		key.interstOps(SelectionKey.OP_WRITE);//读取完成后监听写入事件
	}
	private void write(SelectionKey key) throws IOException{
		output.flip();
		if(channel.isOpen()){
			channel.write(output);//当有写入事件时，将业务处理的结果写入到客户端Channel中
			key.channel();
			channel.close();
			output.clear();
		}
	}
	//进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，则将处理过程放入到线程池里面即可，并且使用一个Future获取处理结果，最后写入到客户端Channel中
	private void process(){
		byte[] bytes = new byte[input.remaining()];
		input.get(bytes);
		String message = new String(bytes,CharsetUtil.UTF_8);
		System.out.println("receive message from client: \n" +message);
		output.put("hello client".getBytes());
	}
}
</code></pre>
<p>在 Handler 中，主要进行的就是每个客户端 Channel 创建一个 Selector，并且监听该 Channel 的网络读写事件。当有事件到达时，进行数据的读写，而业务操作交友具体的业务线程池处理。</p>
<h1 id="三、AIO（-Asynchronous-I-O）"><a href="#三、AIO（-Asynchronous-I-O）" class="headerlink" title="三、AIO（ Asynchronous I/O）"></a>三、AIO（ Asynchronous I/O）</h1><ol>
<li>JDK7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
</ol>
<h3 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h3><p>之前主要介绍了阻塞式同步 IO，非阻塞式同步 IO，多路复用 IO 这三种 IO 模型。而异步 IO 是采用“订阅-通知”模式，即应用程序向操作系统注册 IO 监听，然后继续做自己的事情。当操作系统发生 IO 事件，并且准备好数据后，主动通知应用程序，触发相应的函数：</p>
<p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/3a01157436842562f7f21f8b4c4549d4_MD5.png" loading="lazy"></p>
<p>和同步 IO 一样，异步 IO 也是由操作系统进行支持的。Windows 系统提供了一种异步 IO 技术：IOCP（I/O Completion Port，I/O 完成端口）；<br>Linux 下由于没有这种异步 IO 技术，所以使用的是 epoll（上文介绍过的一种多路复用 IO 技术的实现）对异步 IO 进行模拟。</p>
<h3 id="Java-AIO-框架解析"><a href="#Java-AIO-框架解析" class="headerlink" title="Java AIO 框架解析"></a>Java AIO 框架解析</h3><p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[]" data-src="/img/2ff37cd0e1f5f734f8d6209396a08897_MD5.png" loading="lazy"></p>
<p>以上结构主要是说明 JAVA AIO 中类设计和操作系统的相关性。</p>
<blockquote>
<p>上述所有代码仓库地址：<a target="_blank" rel="noopener" href="https://github.com/z1gui/netty_io">https://github.com/z1gui/netty_io</a></p>
</blockquote>
<p>参考资料：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/520809188?utm_id=0">BIO、NIO、AIO区别详解</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-overview.html">♥Java IO知识体系详解♥</a></p>
</blockquote>

            </div>
            <div class="post-toc" id="postToc">
                <div class="toc-header">
                    <div class="toc-title">目录</div>
                </div>
                <div class="toc-content"></div>
            </div>
        </div>
    

<!-- 只在文章页面显示分类和导航 -->

    <!-- tags -->
    
        <div class="post-meta">
            分类：
            
                            <a href="/categories/%E5%90%8E%E7%AB%AF/"> / 后端</a>

            
        </div>
    

    <!-- 添加上一篇和下一篇导航 -->
    <div class="post-navigation">
        <div class="post-nav-prev">
            
                <span class="nav-label">上一篇</span>
                <a href="/761386768996831/" class="nav-title">Kafka深入浅出</a>
            
        </div>
        <div class="post-nav-next">
            
                <span class="nav-label">下一篇</span>
                <a href="/761386768996885/" class="nav-title">类加载器以及双亲委派模型</a>
            
        </div>
    </div>

</div>

<!-- 图片全屏显示模态框 -->
<div class="image-modal" id="imageModal">
    <img id="modalImage" src="" alt="全屏图片">
</div>

<!-- 代码全屏显示模态框 -->
<div class="code-modal" id="codeModal">
    <div class="code-modal-content">
        <div class="code-modal-header">
            <div class="code-modal-title">代码查看</div>
            <div class="code-modal-close" id="codeModalClose">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
        </div>
        <div class="code-modal-code">
            <pre><code id="modalCode"></code></pre>
        </div>
    </div>
</div>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const postImages = document.querySelectorAll('.post-md img');

    // 点击图片打开模态框
    postImages.forEach(img => {
        // 检查图片是否在社交链接中
        const isSocialIcon = img.closest('.social-links') !== null;
        if (!isSocialIcon) {
            img.addEventListener('click', function() {
                modal.classList.add('active');
                modalImg.src = this.src;
                document.body.style.overflow = 'hidden'; // 防止背景滚动
            });
        }
    });

    // 点击模态框关闭
    modal.addEventListener('click', function() {
        modal.classList.remove('active');
        document.body.style.overflow = ''; // 恢复背景滚动
    });

    // 按 ESC 键关闭模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    });

    // 阅读进度条功能
    const progressBar = document.getElementById('readingProgressBar');
    if (progressBar) {
        function updateReadingProgress() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            
            // 限制进度条宽度在0-100%之间
            const progressWidth = Math.min(Math.max(scrollPercent, 0), 100);
            progressBar.style.width = progressWidth + '%';
        }

        // 监听滚动事件
        window.addEventListener('scroll', updateReadingProgress);
        
        // 页面加载时初始化进度条
        updateReadingProgress();
    }



    // 目录功能已移至工具栏统一管理

    // 代码块全屏功能
    const codeModal = document.getElementById('codeModal');
    const modalCode = document.getElementById('modalCode');
    const codeModalClose = document.getElementById('codeModalClose');

    // 为所有代码块添加全屏按钮
    const codeBlocks = document.querySelectorAll('.post-md pre');
    codeBlocks.forEach(pre => {
        // 检查是否已经有按钮（避免重复添加）
        if (!pre.querySelector('.code-fullscreen-btn')) {
            const fullscreenBtn = document.createElement('div');
            fullscreenBtn.className = 'code-fullscreen-btn';
            fullscreenBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 3H5C3.89543 3 3 3.89543 3 5V8M21 8V5C21 3.89543 20.1046 3 19 3H16M16 21H19C20.1046 21 21 20.1046 21 19V16M3 16V19C3 20.1046 3.89543 21 5 21H8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            fullscreenBtn.title = '全屏查看代码';
            
            // 点击按钮显示全屏代码
            fullscreenBtn.addEventListener('click', function() {
                const codeElement = pre.querySelector('code');
                if (codeElement) {
                    // 检查是否是已经应用了行号的代码块
                    const hljsTable = pre.querySelector('table.hljs-ln');
                    
                    let codeContent;
                    let startLineNumber = 1;
                    
                    if (hljsTable) {
                        // 如果有行号表格，提取纯代码内容和起始行号
                        const codeLines = hljsTable.querySelectorAll('.hljs-ln-code');
                        codeContent = Array.from(codeLines).map(line => {
                            // 提取每行的文本内容，保持原始格式
                            return line.textContent || line.innerText || ' ';
                        }).join('\n');
                        
                        // 获取起始行号
                        const firstNumberCell = hljsTable.querySelector('.hljs-ln-numbers');
                        if (firstNumberCell) {
                            const lineAttr = firstNumberCell.getAttribute('data-line-number');
                            if (lineAttr) {
                                startLineNumber = parseInt(lineAttr) || 1;
                            }
                        }
                    } else {
                        // 普通代码块，直接获取文本内容
                        codeContent = codeElement.textContent || codeElement.innerText;
                    }
                    
                    const codeLanguage = getCodeLanguage(codeElement);
                    
                    // 设置模态框中的代码内容
                    modalCode.textContent = codeContent;
                    modalCode.className = codeElement.className; // 保持代码高亮的类名
                    
                    // 如果原代码有自定义起始行号，设置data属性
                    if (startLineNumber !== 1) {
                        modalCode.setAttribute('data-ln-start-from', startLineNumber);
                    } else {
                        modalCode.removeAttribute('data-ln-start-from');
                    }
                    
                    // 更新标题
                    const modalTitle = document.querySelector('.code-modal-title');
                    if (codeLanguage) {
                        modalTitle.textContent = `代码查看 - ${codeLanguage}`;
                    } else {
                        modalTitle.textContent = '代码查看';
                    }
                    
                    // 显示模态框
                    codeModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    
                    // 重新应用代码高亮和行号
                    if (typeof hljs !== 'undefined') {
                        hljs.highlightElement(modalCode);
                        
                        // 应用行号
                        if (typeof hljs.lineNumbersBlock !== 'undefined') {
                            hljs.lineNumbersBlock(modalCode, {
                                startFrom: startLineNumber
                            });
                        }
                    }
                }
            });
            
            pre.appendChild(fullscreenBtn);
        }
    });

    // 获取代码语言
    function getCodeLanguage(codeElement) {
        const className = codeElement.className;
        const languageMatch = className.match(/language-(\w+)|hljs-(\w+)|\b(\w+)$/);
        if (languageMatch) {
            return languageMatch[1] || languageMatch[2] || languageMatch[3];
        }
        return '';
    }

    // 关闭代码全屏模态框
    function closeCodeModal() {
        codeModal.classList.remove('active');
        document.body.style.overflow = '';
    }

    // 点击关闭按钮
    if (codeModalClose) {
        codeModalClose.addEventListener('click', closeCodeModal);
    }

    // 点击模态框背景关闭（点击内容区域不关闭）
    codeModal.addEventListener('click', function(e) {
        if (e.target === codeModal) {
            closeCodeModal();
        }
    });

    // 按 ESC 键关闭代码模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (codeModal.classList.contains('active')) {
                closeCodeModal();
            }
        }
    });
});
</script>
                <div class="footer">
    <!-- <div class="typewriter-container">
        <span class="typewriter-text" id="typewriter"></span>
        <span class="cursor">|</span>
    </div> -->
    <span>Copyright © <script>document.write(new Date().getFullYear())</script> <a target="_blank" rel="noopener" href="https://github.com/z1gui">z1gui</a></span>
    <span>Licensed under<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC-BY-NC-SA 4.0</a></span>
</div>

<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();

    // 生成目录
    function generateTOC() {
        const tocContent = document.querySelector('.toc-content');
        if (!tocContent) return;

        const headings = document.querySelectorAll('.post-md h1, .post-md h2, .post-md h3, .post-md h4, .post-md h5, .post-md h6');
        
        if (headings.length === 0) {
            const postToc = document.querySelector('.post-toc');
            if (postToc) {
                postToc.style.display = 'none';
            }
            return;
        }

        // 清空现有内容
        tocContent.innerHTML = '';

        const tocList = document.createElement('ul');
        tocList.className = 'toc-list';
        let currentLevel = 0;
        let currentList = tocList;

        // 生成唯一 id
        const idMap = {};
        headings.forEach((heading) => {
            // 修改ID生成逻辑，确保ID以字母开头
            let baseId = heading.textContent.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')  // 将非字母数字字符替换为连字符
                .replace(/^[0-9]+/, 'h-$&')   // 如果以数字开头，添加'h-'前缀
                .replace(/(^-+|-+$)/g, '');   // 移除首尾的连字符
            
            if (!baseId) baseId = 'heading';
            let uniqueId = baseId;
            if (idMap[baseId] !== undefined) {
                idMap[baseId] += 1;
                uniqueId = `${baseId}-${idMap[baseId]}`;
            } else {
                idMap[baseId] = 0;
            }
            heading.id = uniqueId;
        });

        headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName[1]);
            const id = heading.id;

            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = `#${id}`;
            link.textContent = heading.textContent;
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetHeading = document.getElementById(id);
                if (targetHeading) {
                    const headerOffset = 100;
                    const elementPosition = targetHeading.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });

                    // 更新 URL 的 hash
                    history.pushState(null, null, `#${id}`);
                }
            });

            listItem.appendChild(link);

            if (level > currentLevel) {
                const newList = document.createElement('ul');
                newList.className = 'toc-sublist';
                if (currentList.lastChild) {
                    currentList.lastChild.appendChild(newList);
                } else {
                    currentList.appendChild(newList);
                }
                currentList = newList;
            } else if (level < currentLevel) {
                const diff = currentLevel - level;
                for (let i = 0; i < diff && currentList.parentNode && currentList.parentNode.parentNode; i++) {
                    currentList = currentList.parentNode.parentNode;
                }
            }

            if (currentList) {
                currentList.appendChild(listItem);
            }
            currentLevel = level;
        });

        if (tocList) {
            tocContent.appendChild(tocList);
        }

        // 初始化时检查 URL hash 并滚动到对应位置
        if (window.location.hash) {
            const targetId = window.location.hash.slice(1);
            const targetHeading = document.getElementById(targetId);
            if (targetHeading) {
                setTimeout(() => {
                    const headerOffset = 100;
                    const elementPosition = targetHeading.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                }, 100);
            }
        }

        // 添加目录滚动监听
        const tocLinks = document.querySelectorAll('.toc-content a');
        const postToc = document.querySelector('.post-toc');
        let activeLink = null;
        let ticking = false;

        function updateTOCPosition() {
            if (!postToc || !tocContent || !activeLink) return;

            const tocContentRect = tocContent.getBoundingClientRect();
            const activeLinkRect = activeLink.getBoundingClientRect();
            
            // 计算目录内容区域的中心位置
            const tocContentCenter = tocContentRect.top + tocContentRect.height / 2;
            
            // 计算活动链接的中心位置
            const linkCenter = activeLinkRect.top + activeLinkRect.height / 2;
            
            // 计算需要滚动的距离，使活动链接居中
            const scrollDistance = linkCenter - tocContentCenter;
            
            // 计算新的滚动位置
            const newScrollTop = tocContent.scrollTop + scrollDistance;
            
            // 确保滚动位置在有效范围内
            const maxScroll = tocContent.scrollHeight - tocContent.clientHeight;
            const boundedScrollTop = Math.max(0, Math.min(newScrollTop, maxScroll));
            
            // 平滑滚动到新位置
            tocContent.scrollTo({
                top: boundedScrollTop,
                behavior: 'smooth'
            });
        }

        function setActiveLink() {
            if (ticking) return;
            ticking = true;

            requestAnimationFrame(() => {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const headerOffset = 100;
                let currentActive = null;
                let minDistance = Infinity;

                // 找到距离视口顶部最近的标题
                headings.forEach((heading) => {
                    const rect = heading.getBoundingClientRect();
                    const distance = Math.abs(rect.top - headerOffset);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        currentActive = tocLinks[Array.from(headings).indexOf(heading)];
                    }
                });

                // 更新活动链接状态
                if (currentActive !== activeLink) {
                    tocLinks.forEach(link => {
                        if (link === currentActive) {
                            if (!link.classList.contains('active')) {
                                link.classList.add('active');
                                activeLink = link;
                                // 当活动链接改变时，更新目录位置
                                setTimeout(updateTOCPosition, 0);
                            }
                        } else {
                            link.classList.remove('active');
                        }
                    });
                }

                ticking = false;
            });
        }

        // 使用节流函数优化滚动事件处理
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // 监听滚动事件，使用节流函数优化性能
        window.addEventListener('scroll', throttle(() => {
            setActiveLink();
        }, 16)); // 使用约60fps的更新频率

        // 监听窗口大小改变事件
        window.addEventListener('resize', throttle(() => {
            setActiveLink();
            updateTOCPosition();
        }, 100));

        // 初始化时执行一次
        setActiveLink();
    }

    // 确保在DOM完全加载后执行
    document.addEventListener('DOMContentLoaded', () => {
        try {
            generateTOC();
        } catch (error) {
            console.error('Error initializing TOC:', error);
        }
    });
</script>

<style>
.heading-anchor {
    position: absolute;
    left: 0;
    color: var(--font-color-3);
    opacity: 0;
    transition: opacity 0.3s, color 0.3s;
    text-decoration: none;
    cursor: pointer;
}

.heading-anchor:hover {
    color: var(--font-color-0);
}

h1:hover .heading-anchor,
h2:hover .heading-anchor,
h3:hover .heading-anchor,
h4:hover .heading-anchor,
h5:hover .heading-anchor,
h6:hover .heading-anchor {
    opacity: 1;
}

.copy-tooltip {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--font-color-1);
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 1000;
    animation: fadeInOut 2s ease-in-out;
}

@keyframes fadeInOut {
    0% { opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { opacity: 0; }
}
</style>

<!-- 打字机效果脚本 -->
<script src="/js/typewriter.js"></script>

            </div>
        </div>

        <!-- 主题切换JavaScript -->
        <script>
        // 立即设置默认主题，避免闪烁
        (function() {
            const html = document.documentElement;
            const savedTheme = localStorage.getItem('theme');
            
            if (savedTheme) {
                html.setAttribute('data-theme', savedTheme);
            } else {
                // 默认使用黑暗模式
                html.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            }
        })();
        
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('themeToggle');
            const html = document.documentElement;
            
            // 主题切换功能
            themeToggle.addEventListener('click', function() {
                const currentTheme = html.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                html.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                // 添加切换动画
                html.style.transition = 'all 0.3s ease';
                setTimeout(() => {
                    html.style.transition = '';
                }, 300);
            });
            
            // 监听系统主题变化（仅在用户未手动设置主题时）
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
                if (!localStorage.getItem('theme')) {
                    const newTheme = e.matches ? 'dark' : 'light';
                    html.setAttribute('data-theme', newTheme);
                }
            });
            
            // 为文章数量添加动画效果和点击事件
            const articleCountElement = document.getElementById('articleCount');
            const articleCountItem = document.getElementById('articleCountItem');
            if (articleCountElement && articleCountItem) {
                articleCountElement.style.transition = 'transform 0.3s ease';
                articleCountItem.classList.add('clickable');
                
                articleCountItem.addEventListener('mouseenter', function() {
                    articleCountElement.style.transform = 'scale(1.1)';
                });
                articleCountItem.addEventListener('mouseleave', function() {
                    articleCountElement.style.transform = 'scale(1)';
                });
                
                // 点击文章数量跳转到归档页面
                articleCountItem.addEventListener('click', function(e) {
                    e.stopPropagation(); // 阻止事件冒泡
                    
                    // 添加点击反馈效果
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'scale(1)';
                        window.location.href = '/archives/';
                    }, 150);
                });
            }
            
            // 为个人介绍卡片添加点击事件
            const profileCard = document.getElementById('profileCard');
            if (profileCard) {
                profileCard.classList.add('clickable');
                
                // 点击个人介绍卡片跳转到关于页面
                profileCard.addEventListener('click', function(e) {
                    // 如果点击的是文章数量，不执行跳转
                    if (e.target.closest('#articleCountItem')) {
                        return;
                    }
                    
                    // 添加点击反馈效果
                    this.style.transform = 'translateY(-2px) scale(0.98)';
                    setTimeout(() => {
                        this.style.transform = 'translateY(-2px) scale(1.02)';
                        window.location.href = '/about/';
                    }, 150);
                });
            }
            
            // 工具栏显示逻辑
            const backToTopBtn = document.getElementById('backToTop');
            const showTocBtn = document.getElementById('showTocBtn');
            
            if (backToTopBtn) {
                // 显示/隐藏返回顶部按钮
                function toggleBackToTop() {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    if (scrollTop > 300) {
                        backToTopBtn.style.opacity = '1';
                        backToTopBtn.style.visibility = 'visible';
                        backToTopBtn.style.transform = 'translateY(0)';
                    } else {
                        backToTopBtn.style.opacity = '0';
                        backToTopBtn.style.visibility = 'hidden';
                        backToTopBtn.style.transform = 'translateY(20px)';
                    }
                }
                
                // 点击返回顶部
                backToTopBtn.addEventListener('click', function() {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
                
                // 监听滚动事件
                window.addEventListener('scroll', toggleBackToTop);
                toggleBackToTop();
            }
            
            // 返回主页按钮功能（仅在文章页面）
            const homeBtn = document.getElementById('homeBtn');
            if (homeBtn) {
                homeBtn.addEventListener('click', function() {
                    window.location.href = '/';
                });
            }
            
            // 目录切换按钮功能（仅在文章页面）
            const tocToggleBtn = document.getElementById('tocToggleBtn');
            if (tocToggleBtn) {
                const postToc = document.getElementById('postToc');
                
                // 从localStorage获取目录状态
                const tocHidden = localStorage.getItem('tocHidden') === 'true';
                if (tocHidden && postToc) {
                    postToc.classList.add('hidden');
                    tocToggleBtn.classList.add('hidden');
                }
                
                // 点击切换目录显示/隐藏
                tocToggleBtn.addEventListener('click', function() {
                    if (postToc) {
                        const isHidden = postToc.classList.contains('hidden');
                        if (isHidden) {
                            postToc.classList.remove('hidden');
                            this.classList.remove('hidden');
                            localStorage.setItem('tocHidden', 'false');
                        } else {
                            postToc.classList.add('hidden');
                            this.classList.add('hidden');
                            localStorage.setItem('tocHidden', 'true');
                        }
                    }
                });
            }
        });
        </script>
            }
        });
        
    
</body></html>