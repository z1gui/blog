<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport">
  <meta name="robots" content="index, follow">
  <!-- title -->
  
    
  <title>javascript中 const，var，let的区别 - 子规入梧桐</title>
    
  
  
  <!-- open graph -->
  <meta name="description" content="var、const、let 同样都是声明变量的关键词。 一、var 和 let 区别作用域var 的作用域只能是全局或者是整个函数块，而 let 的作用域既可以是全局变量或者是整个函数，还可以是 if, while, switch 限定的代码块。 function varTest() { 	 	var a = 1;   	{     		var a = 2; // 函数块中，同">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript中 const，var，let的区别">
<meta property="og:url" content="https://www.lazydaily.cn/761386768996512/index.html">
<meta property="og:site_name" content="子规入梧桐">
<meta property="og:description" content="var、const、let 同样都是声明变量的关键词。 一、var 和 let 区别作用域var 的作用域只能是全局或者是整个函数块，而 let 的作用域既可以是全局变量或者是整个函数，还可以是 if, while, switch 限定的代码块。 function varTest() { 	 	var a = 1;   	{     		var a = 2; // 函数块中，同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lazydaily.cn/img/d81d47f1a51cc2ecfe16e8966e7949b8_MD5.jpeg">
<meta property="article:published_time" content="2024-07-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-20T07:22:19.700Z">
<meta property="article:author" content="z1gui">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lazydaily.cn/img/d81d47f1a51cc2ecfe16e8966e7949b8_MD5.jpeg">
  <!-- canonical -->
  
  <link rel="canonical" href="https://www.lazydaily.cn/761386768996512/">
  
  <!-- Favicon -->
  <link rel="shortcut icon" href="/img/favicon.png">
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;0,900;1,400&amp;display=swap" rel="stylesheet">
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/reset.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/markdown.css">

  
<link rel="stylesheet" href="/css/fonts.css">

  
<script src="/js/toc.js"></script>

  

  
  <!-- 图片懒加载 -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const lazyImages = document.querySelectorAll('img[data-src]');
      
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            observer.unobserve(img);
          }
        });
      });

      lazyImages.forEach(img => imageObserver.observe(img));
    });
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="子规入梧桐" type="application/atom+xml">
</head>

    <body>
        <!-- 固定工具栏 -->
        <div class="fixed-toolbar">
        </div>
        
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <ul class="nav">
        
        <li>
            
            <a href="/" class="">主页</a>
        </li>
        
        <li>
            
            <a href="/archives" class="">归档</a>
        </li>
        
        <li>
            
            <a href="/about" class="">关于</a>
        </li>
        
        <li>
            
            <a href="/use" class="">设备</a>
        </li>
        
    </ul>
</div>

                
                <div class="post-main">
    <!-- 阅读进度条 -->
    <div class="reading-progress-bar" id="readingProgressBar"></div>
    
    
        <div class="post-main-title">
            javascript中 const，var，let的区别
        </div>
        <div class="post-meta">
            2024-07-23 ｜ 
            
                <a href="/tags/javascript/"># javascript</a>
            
        </div>
        <div class="post-content-wrapper">
            <div class="post-content-main">
                <div class="post-md">
                    <p>var、const、let 同样都是声明变量的关键词。</p>
<h2 id="一、var-和-let-区别"><a href="#一、var-和-let-区别" class="headerlink" title="一、var 和 let 区别"></a>一、var 和 let 区别</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>var 的作用域只能是全局或者是整个函数块，而 let 的作用域既可以是全局变量或者是整个函数，还可以是 if, while, switch 限定的代码块。</p>
<pre><code class="language-javascript">function varTest() {
	
	var a = 1;  
	{    
		var a = 2; // 函数块中，同一个变量 
		console.log(a); // 2  
	}  
	 console.log(a); // 2
}

 function letTest() {  
	 let a = 1;  
	 {    
		 let a = 2; // 代码块中，新的变量    
		 console.log(a); // 2  
	 }  
	 console.log(a); // 1
 }
 varTest();
 letTest();
</code></pre>
<p>let 声明的变量，可以比 var 声明的变量的作用有更小的限定范围，更加灵活。</p>
<h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p>在同一个作用域中，var 允许重复声明，但是 let 不允许重复声明。</p>
<pre><code class="language-javascript">var a = 1;
var a = 2;
console.log(a) // 2
function test() { 
 var a = 3;  
 var a = 4;  
 console.log(a) // 4
 }
 test()


if(false) {  
	let a = 1;  
	let a = 2; // SyntaxError: Identifier 'a' has already been declared}
}

switch(index) {  
	case 0:    
		let a = 1;  
		break;  
	default:    
		let a = 2; // SyntaxError: Identifier 'a' has already been declared    
		break;
}
</code></pre>
<h3 id="绑定全局变量"><a href="#绑定全局变量" class="headerlink" title="绑定全局变量"></a>绑定全局变量</h3><p>var 在全局环境声明变量，会在全局对象里新建一个属性，而 let 在全局环境声明变量，则不会在全局对象里新建一个属性。</p>
<pre><code class="language-javascript">var foo = 'global'
let bar = 'global'
console.log(this.foo) // global
console.log(this.bar) // undefined
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="[d81d47f1a51cc2ecfe16e8966e7949b8_MD5.jpeg]" data-src="/img/d81d47f1a51cc2ecfe16e8966e7949b8_MD5.jpeg" loading="lazy"></p>
<p>由上图可知，let 在全局环境声明变量 bar 保存在[[Scopes]][0]: Script 这个变量对象的属性中，而 [[Scopes]][1]: Global 就是我们常说的全局对象。</p>
<h3 id="变量提升和暂存死区"><a href="#变量提升和暂存死区" class="headerlink" title="变量提升和暂存死区"></a>变量提升和暂存死区</h3><p>了解变量提升，就需要了解到上线文和变量对象。详见<a href="/md/js/%E8%AF%A6%E8%A7%A3%EF%BC%9AJavaScript%E5%88%9B%E5%BB%BA%E6%89%A7%E8%A1%8C%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B.md">详解：javascript 创建执行释放过程</a></p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>所有使用 var 声明的变量都会在执行上下文的创建阶段时作为变量对象的属性被创建并初始化，这样才能保证在执行阶段能通过标识符在变量对象里找到对应变量进行赋值操作等。即 var 在声明变量构建变量的时：</p>
<ol>
<li>由名称和 undefined（形参）组成一个变量对象的属性创建（创建并初始化）</li>
<li>如果变量名称和之前的形参或者函数相同，则变量声明不会干扰已经存在的这类属性。</li>
</ol>
<pre><code class="language-javascript">console.log(a) // undefined
var a = 1;
console.log(a) // 1
</code></pre>
<p>为什么 var 变量可以在声明之前使用，因为使用是在执行阶段，而在此之前的创建阶段就已经将声明的变量添加到了变量对象中，所以执行阶段通过标识符可以在变量对象中查找到，也就不会报错。</p>
<h4 id="暂存死区"><a href="#暂存死区" class="headerlink" title="暂存死区"></a>暂存死区</h4><p>其实 let 也存在与 var 类似的“变量提升”过程，但与 var 不同的是其在执行上下文的创建阶段，只会创建变量而不会被初始化（undefined），并且 ES6 规定了其初始化过程是在执行上下文的执行阶段（即直到它们的定义被执行时才初始化），使用未被初始化的变量将会报错。</p>
<blockquote>
<p>let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value&nbsp;<strong>undefined</strong>&nbsp;when the LexicalBinding is evaluated.</p>
</blockquote>
<p>在变量初始化前访问该变量会导致 ReferenceError，因此从进入作用域创建变量，到变量开始可被访问的一段时间（过程），就称为暂存死区(Temporal Dead Zone)。</p>
<pre><code class="language-javascript">console.log(bar); // undefined
console.log(foo); // ReferenceError: foo is not defined
var bar = 1;
let foo = 2;


var foo = 33;
	{  
		let foo = (foo + 55); // ReferenceError: foo is not defined
	}
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>var 声明的变量在执行上下文创建阶段就会被「创建」和「初始化」，因此对于执行阶段来说，可以在声明之前使用。</li>
<li>let 声明的变量在执行上下文创建阶段只会被「创建」而不会被「初始化」，因此对于执行阶段来说，如果在其定义执行前使用，相当于使用了未被初始化的变量，会报错。</li>
</ol>
<h2 id="二、let-和-const-区别"><a href="#二、let-和-const-区别" class="headerlink" title="二、let 和 const 区别"></a>二、let 和 const 区别</h2><p>const 与 let 很类似，都具有上面提到的 let 的特性，唯一区别就在于 const 声明的是一个只读变量，声明之后不允许改变其值。因此，const 一旦声明必须初始化，否则会报错。</p>
<p>示例代码：</p>
<pre><code class="language-javascript">let a;
const b = "constant"
a = "variable"
b = 'change' // TypeError: Assignment to constant variable
</code></pre>
<p><strong>如何理解声明之后不允许改变其值？</strong></p>
<p>其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动（即栈内存在的值和地址）。</p>
<p>javascript 的数据类型分为两类：原始值类型和对象（Object类型）。</p>
<p>对于原始值类型（undefined、null、true/false、number、string），值就保存在变量指向的那个内存地址（在栈中），因此 const 声明的原始值类型变量等同于常量。</p>
<p>对于对象类型（object，array，function等），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是不可修改的，至于指针指向的数据结构是无法保证其不能被修改的（在堆中）。</p>
<p>示例代码：</p>
<pre><code class="language-javascript">const obj = {  value: 1}
obj.value = 2;
console.log(obj) // { value: 2 }obj = {}
</code></pre>
<p>参考资料：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/556482226?utm_id=0">深入理解 JS：var、let、const 的异同</a></p>
</blockquote>

                </div>
            </div>
            <div class="post-content-sidebar">
                <div class="toc-toggle-btn" id="tocToggleBtn" title="显示目录">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                    </svg>
                </div>
                <div class="post-toc" id="postToc">
                    <div class="toc-header">
                        <div class="toc-title">目录</div>
                    </div>
                    <div class="toc-content"></div>
                </div>
            </div>
        </div>
    

<!-- 只在文章页面显示分类和导航 -->

    <!-- 分类信息 -->
    
        <div class="post-categories">
            分类：
            
                <a href="/categories/%E5%89%8D%E7%AB%AF/"> / 前端</a>
            
        </div>
    

    <!-- 添加上一篇和下一篇导航 -->
    <div class="post-navigation">
        <div class="post-nav-prev">
            
                <span class="nav-label">上一篇</span>
                <a href="/761386768996885/" class="nav-title">类加载器以及双亲委派模型</a>
            
        </div>
        <div class="post-nav-next">
            
                <span class="nav-label">下一篇</span>
                <a href="/7613867548996883/" class="nav-title">为什么总是乱码？来看看编码格式吧</a>
            
        </div>
    </div>

</div>

<!-- 图片全屏显示模态框 -->
<div class="image-modal" id="imageModal">
    <img id="modalImage" src="" alt="全屏图片">
</div>

<!-- 代码全屏显示模态框 -->
<div class="code-modal" id="codeModal">
    <div class="code-modal-content">
        <div class="code-modal-header">
            <div class="code-modal-title">代码查看</div>
            <div class="code-modal-close" id="codeModalClose">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </div>
        </div>
        <div class="code-modal-code">
            <pre><code id="modalCode"></code></pre>
        </div>
    </div>
</div>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const postImages = document.querySelectorAll('.post-md img');

    // 点击图片打开模态框
    postImages.forEach(img => {
        // 检查图片是否在社交链接中
        const isSocialIcon = img.closest('.social-links') !== null;
        if (!isSocialIcon) {
            img.addEventListener('click', function() {
                modal.classList.add('active');
                modalImg.src = this.src;
                document.body.style.overflow = 'hidden'; // 防止背景滚动
            });
        }
    });

    // 点击模态框关闭
    modal.addEventListener('click', function() {
        modal.classList.remove('active');
        document.body.style.overflow = ''; // 恢复背景滚动
    });

    // 按 ESC 键关闭模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    });

    // 阅读进度条功能
    const progressBar = document.getElementById('readingProgressBar');
    if (progressBar) {
        function updateReadingProgress() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            
            // 限制进度条宽度在0-100%之间
            const progressWidth = Math.min(Math.max(scrollPercent, 0), 100);
            progressBar.style.width = progressWidth + '%';
        }

        // 监听滚动事件
        window.addEventListener('scroll', updateReadingProgress);
        
        // 页面加载时初始化进度条
        updateReadingProgress();
    }



    // 目录功能已移至工具栏统一管理

    // 代码块全屏功能
    const codeModal = document.getElementById('codeModal');
    const modalCode = document.getElementById('modalCode');
    const codeModalClose = document.getElementById('codeModalClose');

    // 为所有代码块添加全屏按钮
    const codeBlocks = document.querySelectorAll('.post-md pre');
    codeBlocks.forEach(pre => {
        // 检查是否已经有按钮（避免重复添加）
        if (!pre.querySelector('.code-fullscreen-btn')) {
            const fullscreenBtn = document.createElement('div');
            fullscreenBtn.className = 'code-fullscreen-btn';
            fullscreenBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 3H5C3.89543 3 3 3.89543 3 5V8M21 8V5C21 3.89543 20.1046 3 19 3H16M16 21H19C20.1046 21 21 20.1046 21 19V16M3 16V19C3 20.1046 3.89543 21 5 21H8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            fullscreenBtn.title = '全屏查看代码';
            
            // 点击按钮显示全屏代码
            fullscreenBtn.addEventListener('click', function() {
                const codeElement = pre.querySelector('code');
                if (codeElement) {
                    // 检查是否是已经应用了行号的代码块
                    const hljsTable = pre.querySelector('table.hljs-ln');
                    
                    let codeContent;
                    let startLineNumber = 1;
                    
                    if (hljsTable) {
                        // 如果有行号表格，提取纯代码内容和起始行号
                        const codeLines = hljsTable.querySelectorAll('.hljs-ln-code');
                        codeContent = Array.from(codeLines).map(line => {
                            // 提取每行的文本内容，保持原始格式
                            return line.textContent || line.innerText || ' ';
                        }).join('\n');
                        
                        // 获取起始行号
                        const firstNumberCell = hljsTable.querySelector('.hljs-ln-numbers');
                        if (firstNumberCell) {
                            const lineAttr = firstNumberCell.getAttribute('data-line-number');
                            if (lineAttr) {
                                startLineNumber = parseInt(lineAttr) || 1;
                            }
                        }
                    } else {
                        // 普通代码块，直接获取文本内容
                        codeContent = codeElement.textContent || codeElement.innerText;
                    }
                    
                    const codeLanguage = getCodeLanguage(codeElement);
                    
                    // 设置模态框中的代码内容
                    modalCode.textContent = codeContent;
                    modalCode.className = codeElement.className; // 保持代码高亮的类名
                    
                    // 如果原代码有自定义起始行号，设置data属性
                    if (startLineNumber !== 1) {
                        modalCode.setAttribute('data-ln-start-from', startLineNumber);
                    } else {
                        modalCode.removeAttribute('data-ln-start-from');
                    }
                    
                    // 更新标题
                    const modalTitle = document.querySelector('.code-modal-title');
                    if (codeLanguage) {
                        modalTitle.textContent = `代码查看 - ${codeLanguage}`;
                    } else {
                        modalTitle.textContent = '代码查看';
                    }
                    
                    // 显示模态框
                    codeModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    
                    // 重新应用代码高亮和行号
                    if (typeof hljs !== 'undefined') {
                        hljs.highlightElement(modalCode);
                        
                        // 应用行号
                        if (typeof hljs.lineNumbersBlock !== 'undefined') {
                            hljs.lineNumbersBlock(modalCode, {
                                startFrom: startLineNumber
                            });
                        }
                    }
                }
            });
            
            pre.appendChild(fullscreenBtn);
        }
    });

    // 获取代码语言
    function getCodeLanguage(codeElement) {
        const className = codeElement.className;
        const languageMatch = className.match(/language-(\w+)|hljs-(\w+)|\b(\w+)$/);
        if (languageMatch) {
            return languageMatch[1] || languageMatch[2] || languageMatch[3];
        }
        return '';
    }

    // 关闭代码全屏模态框
    function closeCodeModal() {
        codeModal.classList.remove('active');
        document.body.style.overflow = '';
    }

    // 点击关闭按钮
    if (codeModalClose) {
        codeModalClose.addEventListener('click', closeCodeModal);
    }

    // 点击模态框背景关闭（点击内容区域不关闭）
    codeModal.addEventListener('click', function(e) {
        if (e.target === codeModal) {
            closeCodeModal();
        }
    });

    // 按 ESC 键关闭代码模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (codeModal.classList.contains('active')) {
                closeCodeModal();
            }
        }
    });
});
</script>
                
            </div>
        </div>

        <!-- JavaScript -->
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const html = document.documentElement;
            const nav = document.querySelector('.nav');
            
            // 导航栏滚动显示/隐藏功能
            let lastScrollTop = 0;
            let scrollThreshold = 3; // 滚动阈值，避免微小滚动触发
            
            function handleNavScroll() {
                if (!nav) return;
                
                const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                // 计算滚动距离
                const scrollDifference = currentScrollTop - lastScrollTop;
                
                console.log('滚动位置:', currentScrollTop, '滚动差异:', scrollDifference, '阈值:', scrollThreshold);
                
                // 向下滚动隐藏
                if (scrollDifference > scrollThreshold && currentScrollTop > 30) {
                    nav.classList.add('hidden');
                    console.log('向下滚动，隐藏导航栏');
                }
                // 向上滚动显示
                else if (scrollDifference < -scrollThreshold) {
                    nav.classList.remove('hidden');
                    console.log('向上滚动，显示导航栏');
                }
                // 在页面顶部时显示
                else if (currentScrollTop <= 30) {
                    nav.classList.remove('hidden');
                    console.log('在页面顶部，显示导航栏');
                }
                
                lastScrollTop = currentScrollTop;
            }
            
            // 监听滚动事件
            window.addEventListener('scroll', handleNavScroll, { passive: true });
            
            // 页面加载时显示导航栏
            if (nav) {
                nav.classList.remove('hidden');
            }
            
            // 目录切换按钮功能（仅在文章页面）
            const tocToggleBtn = document.getElementById('tocToggleBtn');
            if (tocToggleBtn) {
                const postToc = document.getElementById('postToc');
                
                // 从localStorage获取目录状态
                const tocHidden = localStorage.getItem('tocHidden') === 'true';
                if (tocHidden && postToc) {
                    postToc.classList.add('hidden');
                    tocToggleBtn.classList.add('hidden');
                }
                
                // 点击切换目录显示/隐藏
                tocToggleBtn.addEventListener('click', function() {
                    if (postToc) {
                        const isHidden = postToc.classList.contains('hidden');
                        if (isHidden) {
                            postToc.classList.remove('hidden');
                            this.classList.remove('hidden');
                            localStorage.setItem('tocHidden', 'false');
                        } else {
                            postToc.classList.add('hidden');
                            this.classList.add('hidden');
                            localStorage.setItem('tocHidden', 'true');
                        }
                    }
                });
            }
        });
        </script>
    
</body></html>